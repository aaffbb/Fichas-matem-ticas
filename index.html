<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Hojas de Matem√°ticas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Estilos para el modal de alerta personalizado */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-backdrop.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-backdrop.visible .modal-content {
            transform: scale(1);
        }
        /* Clase para ocultar visualmente el checkmark si es necesario */
        .check-icon {
            display: inline-block;
            margin-left: 0.5rem;
        }
        .control-button.selected .check-icon {
            display: inline-block;
        }
        .control-button:not(.selected) .check-icon {
            display: none;
        }
        /* Estilos espec√≠ficos para las series */
        .series-problem {
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Alinea al inicio para que no se estire */
            flex-wrap: nowrap; /* !IMPORTANT: Prevents wrapping to next line */
            gap: 0.2rem; /* Espacio entre los elementos de la serie, ligeramente reducido */
            font-family: 'Inter', sans-serif; /* Fuente consistente */
            font-size: 1.1rem; /* Ajuste para que quepa bien */
            padding: 0.4rem 0;
            overflow-x: auto; /* Permite desplazamiento si la serie es demasiado larga (como fallback) */
        }
        .series-number-box {
            border: 2px solid #333; /* M√°s grueso y m√°s oscuro */
            padding: 0.25rem 0.4rem 0.25rem 0.4rem; /* Adjusted padding: top, right, bottom, left */
            border-radius: 0.4rem;
            min-width: 3rem; /* Reduced min-width */
            height: 2.2rem; /* Reduced height slightly */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.05);
            background-color: #e0e0e0; /* Un gris claro sutil */
            color: #1a1a1a; /* Texto m√°s oscuro dentro de la caja */
            box-sizing: border-box; /* Added for consistent sizing */
            line-height: 1; /* Ensure text sits well */
            font-size: 1rem; /* Slightly reduced font size */
        }
        .series-arrow {
            font-weight: bold;
            color: #333; /* M√°s oscuro */
            font-size: 1.1rem; /* Ligeramente m√°s grande */
        }
        .series-pattern-op {
            color: #1a1a1a; /* Casi negro */
            font-weight: bolder; /* M√°s negrita */
            font-size: 0.95rem; /* Un poco m√°s peque√±o */
            min-width: 1.6rem; /* Reduced min-width */
            text-align: center;
        }
        /* Ajuste para el grid de problemas para que las series ocupen todo el ancho si es necesario */
        .problems-container-series {
            display: flex; /* Usamos flex para que cada serie ocupe todo el ancho */
            flex-direction: column;
            gap: 1.2rem; /* Espacio entre cada serie, ajustado para 12 series */
            /* Quitar las propiedades de grid para que las series se expandan horizontalmente */
            grid-template-columns: none !important;
        }
        .problems-container-normal {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 1.5rem; /* Espacio entre problemas normales */
        }

        /* Nuevos estilos para problemas normales (sumas, restas, multiplicaciones) */
        .problem-math-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Alinea todo el bloque a la derecha */
            font-size: 1.8rem; /* Tama√±o de fuente base reducido */
            line-height: 1.1; /* L√≠nea de altura reducida */
            width: fit-content; /* Se ajusta al contenido */
            margin-left: auto; /* Centra el problema en su celda */
            margin-right: auto;
            padding-bottom: 0.4rem; /* Espacio al final reducido */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Fuente monoespaciada para alineaci√≥n de d√≠gitos */
        }

        .problem-line {
            display: flex;
            justify-content: flex-end; /* Alinea los n√∫meros a la derecha */
            width: 100%; /* Ocupa el ancho del wrapper */
        }

        .number-operand-top {
            text-align: right;
            min-width: 5ch; /* Reducido para ajustarse a menos d√≠gitos */
        }

        .problem-line-bottom {
            margin-top: -0.1rem; /* Margen superior reducido */
            padding-bottom: 0.8rem; /* AUMENTADO: Padding inferior para separar la l√≠nea */
            border-bottom: 2px solid #333;
            position: relative;
            width: 100%;
            display: flex;
            align-items: baseline; /* Alinea el operador y el n√∫mero base */
            justify-content: flex-end;
        }

        .operator-operand {
            flex-shrink: 0;
            text-align: left;
            width: 1.3rem; /* Ancho reducido */
            padding-right: 0.1rem;
            font-size: 1.3rem; /* Tama√±o de fuente reducido */
            color: #1a1a1a;
            transform: translateY(0.2rem); /* Ajuste vertical para alinear con el n√∫mero */
        }

        .number-operand-bottom {
            text-align: right;
            flex-grow: 1; /* Permite que el n√∫mero ocupe el resto del espacio */
            min-width: 4ch; /* Reducido para ajustarse a menos d√≠gitos */
        }

        .result-line-display {
            text-align: right;
            font-weight: bold;
            color: #1a1a1a;
            margin-top: 0.4rem; /* Espacio entre la l√≠nea de resultado y el n√∫mero reducido */
            width: 100%;
        }

        .empty-result-space {
            display: block; /* Para que ocupe espacio y mantenga la estructura */
            height: 1.3rem; /* Altura para el espacio vac√≠o del resultado reducido */
            width: 100%;
        }

        /* Estilos espec√≠ficos para las pir√°mides */
        .pyramid-problem {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centra cada capa horizontalmente */
            gap: 0.4rem; /* Espacio entre capas reducido */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Fuente monoespaciada */
            font-size: 1.3rem; /* Tama√±o de fuente para n√∫meros de pir√°mide reducido */
            padding: 0.8rem 0; /* Padding reducido */
            margin-bottom: 0.8rem; /* Margen inferior reducido */
            border: 1px solid #ddd;
            border-radius: 0.6rem; /* Radio de borde reducido */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.05); /* Sombra reducida */
            background-color: #f9f9f9;
        }

        .pyramid-layer {
            display: flex;
            justify-content: center; /* Centra los n√∫meros dentro de la capa */
            gap: 0.4rem; /* Espacio entre los n√∫meros en la misma capa reducido */
            width: 100%;
        }

        .pyramid-number-box {
            border: 2px solid #333; /* Estilo similar a las series */
            padding: 0.3rem 0.5rem 0.1rem 0.5rem; /* Adjusted padding: top, right, bottom, left */
            border-radius: 0.3rem; /* Radio de borde reducido */
            min-width: 4.0rem; /* Reducido */
            height: 2.5rem; /* Reducido */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            background-color: #e0e0e0;
            color: #1a1a1a;
            box-sizing: border-box; /* Added for consistent sizing */
            line-height: 1; /* Ensure text sits well */
            font-size: 1.3rem; /* Reducido */
        }

        .pyramid-number-box.empty {
            background-color: #ffffff; /* Fondo blanco para las casillas vac√≠as */
        }

        /* Estilos para el indicador de carga */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Mayor que el modal de alerta */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .loading-content {
            background-color: white;
            padding: 2rem 3rem;
            border-radius: 1.5rem;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .loading-overlay.visible .loading-content {
            transform: scale(1);
        }
        .loading-icon {
            font-size: 4rem; /* Tama√±o del icono */
            animation: spin 2s linear infinite; /* Animaci√≥n de giro */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- NUEVOS ESTILOS PARA VISTA PREVIA Y TABLAS --- */
        #preview-container {
            max-width: 840px; /* Ancho m√°ximo para la vista previa */
            margin-left: auto;
            margin-right: auto;
            padding: 2rem;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
        }

        #worksheet {
            /* Estilos para la vista previa en el navegador */
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            aspect-ratio: 210 / 297; /* Proporci√≥n A4 para la vista previa */
            width: 100%; /* Ocupa el 100% del contenedor de vista previa */
            overflow: hidden; /* Oculta el contenido que se desborda */
            padding: 5%; /* Padding relativo para la vista previa */
            display: flex;
            flex-direction: column;
        }

        #problems-container {
            flex-grow: 1; /* Permite que el contenedor de problemas crezca para llenar el espacio */
        }

        /* Estilos para las tablas num√©ricas y pitag√≥ricas */
        .number-grid-container, .pitagorica-grid-wrapper {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            padding: 0.8rem; /* Padding interno para las tablas reducido */
            display: flex;
            flex-direction: column;
        }

        .number-grid-row {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 columnas de igual ancho */
            gap: 0.1rem; /* Gap reducido */
            flex: 1; /* Permite que las filas crezcan para llenar el espacio */
        }
        
        /* Modificado: Nueva clase para la cuadr√≠cula completa de la tabla pitag√≥rica */
        .pitagorica-full-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 11 columnas, todas iguales */
            grid-template-rows: repeat(11, 1fr);    /* 11 filas, todas iguales */
            gap: 0.1rem;
            width: 100%;
            height: 100%;
        }

        .pitagorica-header-cell {
            background-color: #e0e0e0; /* Fondo gris para los encabezados */
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #666; /* Borde m√°s fino */
            border-radius: 0.15rem; /* Radio de borde reducido */
            box-sizing: border-box;
            aspect-ratio: 1 / 1; /* Mantiene las celdas cuadradas */
            font-size: 1.2vw; /* Escala con el ancho del viewport para la vista previa */
            min-width: 18px; /* Evita que las celdas sean demasiado peque√±as */
            min-height: 18px; /* Evita que las celdas sean demasiado peque√±as */
        }

        .pitagorica-header-cell.empty-corner {
            border: none;
            background: transparent;
            font-size: 1.6vw; /* Escala la 'X' con el viewport */
            font-weight: 900;
        }

        .number-grid-cell { /* Re-usado para las celdas de datos de la tabla pitag√≥rica */
            width: auto; /* Ancho autom√°tico en el grid */
            height: auto; /* Altura autom√°tica en el grid */
            aspect-ratio: 1 / 1; /* Mantiene las celdas cuadradas */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #666; /* Borde m√°s fino */
            background-color: #fff;
            font-weight: 500;
            color: #333;
            border-radius: 0.15rem; /* Radio de borde reducido */
            box-sizing: border-box;
            font-size: 1.2vw; /* Escala con el ancho del viewport para la vista previa */
            min-width: 18px; /* Evita que las celdas sean demasiado peque√±as */
            min-height: 18px; /* Evita que las celdas sean demasiado peque√±as */
        }

        .number-grid-cell input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            background-color: transparent;
            font-size: inherit; /* Hereda el tama√±o de fuente del padre */
            font-weight: 500;
            color: #333;
            -moz-appearance: textfield;
        }

        .number-grid-cell.prefilled {
            background-color: #e0e0e0;
            font-weight: bold;
            color: #1a1a1a;
        }
        
        /* Estilos actualizados para Diana Multiplicaciones (blanco y negro con l√≠neas divisorias) */
        .diana-multiplicaciones-problem {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 200px;
            height: 200px;
            margin: auto;
            background-color: white;
        }

        .diana-center {
            width: 50px;
            height: 50px;
            background-color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: bold;
            color: black;
            border: 2px solid black;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }

        .diana-ring {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .diana-ring.inner {
            width: 110px;
            height: 110px;
            border: 2px solid black;
            background-color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .diana-ring.outer {
            width: 180px;
            height: 180px;
            border: 2px solid black;
            background-color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .diana-ring-item {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            color: black;
        }

        .diana-answer-box input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: 1px solid black;
            border-radius: 0.2rem;
            background-color: white;
            font-size: 0.8rem;
            font-weight: bold;
            color: black;
            -moz-appearance: textfield;
        }

        .diana-answer-box input::-webkit-outer-spin-button,
        .diana-answer-box input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .series-problem {
                font-size: 0.9rem;
            }
            .series-number-box {
                min-width: 2.2rem;
                padding: 0.2rem 0.5rem;
                height: 2.0rem;
                font-size: 0.9rem;
            }
            .series-pattern-op {
                font-size: 0.9rem;
                min-width: 1.8rem;
            }
            .problem-math-wrapper {
                font-size: 1.5rem; /* Ajuste de tama√±o de fuente para m√≥viles */
            }

            /* Responsive para pir√°mides */
            #problems-container[style*="grid-template-columns: repeat(4"] {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
            #problems-container[style*="grid-template-columns: repeat(3"] { /* For 4-2-1 base */
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
            #problems-container[style*="grid-template-columns: repeat(2"] { /* For 8-4-2-1 base */
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
             }
            
            /* Responsive para Diana Multiplicaciones */
            .diana-multiplicaciones-problem {
                width: 180px; /* Ajuste para pantallas m√°s peque√±as */
                height: 180px;
            }
            .diana-center {
                width: 40px; /* Ajuste para pantallas m√°s peque√±as */
                height: 40px;
                font-size: 1.2rem;
            }
            .diana-ring.inner {
                width: 90px; /* Ajuste para pantallas m√°s peque√±as */
                height: 90px;
            }
            .diana-ring.outer {
                width: 150px; /* Ajuste para pantallas m√°s peque√±as */
                height: 150px;
            }
            .diana-ring-item {
                width: 18px; /* Ajuste para pantallas m√°s peque√±as */
                height: 18px;
                font-size: 0.7rem;
            }
            .diana-answer-box input {
                font-size: 0.7rem;
            }

            /* Adjust font size for tables on smaller screens */
            .number-grid-cell, .pitagorica-header-cell {
                font-size: 2.2vw; /* Adjust for mobile preview */
            }
            .pitagorica-header-cell.empty-corner {
                font-size: 2.5vw;
            }
        }
        
        @media (min-width: 840px) {
            /* Fixed font size for tables on larger screens for better PDF consistency */
            .number-grid-cell, .pitagorica-header-cell {
                font-size: 1.0rem; /* Ajustado para pantallas grandes */
            }
             .pitagorica-header-cell.empty-corner {
                font-size: 1.3rem; /* Ajustado para pantallas grandes */
            }
        }

        @media (max-width: 500px) { /* Even smaller screens, specifically for 4-2-1 and 2-1 bases */
             #problems-container[style*="grid-template-columns: repeat(2, minmax(0, 1fr))"] {
                 grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
             }
        }

        /* Nuevos estilos para el encabezado de la hoja de trabajo */
        .ascii-logo {
            line-height: 1;
            letter-spacing: 2px;
            color: #333;
            /* Se elimin√≥ text-align: center; porque el contenedor flex lo manejar√° */
            /* Se eliminaron los m√°rgenes verticales ya que se controlan por el contenedor flex */
        }
        .ascii-logo pre {
            font-size: 1.0rem; /* Tama√±o del logo ASCII reducido */
        }
        .worksheet-title {
            text-align: left; /* Alineado a la izquierda dentro del contenedor flex */
            font-size: 1.4rem; /* Tama√±o del t√≠tulo reducido */
            font-weight: 800;
            letter-spacing: 1px;
            color: #23395d;
            margin: 0; /* Elimina m√°rgenes para que el contenedor flex controle el espaciado */
        }
        .worksheet-name-container {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 1.1rem; /* Tama√±o de la fuente del nombre reducido */
            margin-bottom: 2.5rem; /* Margen inferior ajustado para dejar m√°s espacio */
            margin-top: 0rem; /* Margen superior ajustado a 0 para reducir el espacio */
            justify-content: flex-start;
        }
        .worksheet-name-label {
            font-weight: 600;
            color: #1a237e;
        }
        .worksheet-name-line {
            border-bottom: 1px dotted #333; /* Borde m√°s fino */
            flex-grow: 1;
            height: 1.2em; /* Altura ajustada */
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="max-w-7xl mx-auto p-4 sm:p-8">
        <header class="relative flex items-center justify-center mb-8">
            <div class="text-center">
                <h1 class="text-4xl md:text-5xl font-bold text-gray-800">Generador de Hojas de Matem√°ticas</h1>
                <p class="text-lg text-gray-600 mt-2">Crea y descarga hojas de ejercicios personalizadas.</p>
            </div>
            <!-- ASCII Logo para la parte superior derecha de la p√°gina web principal -->
            <div class="absolute right-4 top-4" aria-hidden="true">
                <pre style="margin:0; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; line-height: 1; color:#333;">
‚ïî‚ïê‚ï¶‚ïê‚ï¶‚ïê
‚ï†‚ïê‚ï¨‚ïê‚ï¨‚ïê
‚ïö‚ïê‚ïù</pre>
            </div>
        </header>

        <!-- Panel de Controles -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8 p-6 bg-white rounded-2xl shadow-lg">
            <!-- Columna 1: Tipo de Operaci√≥n -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">1. Tipo de Operaci√≥n</h3>
                <div id="operation-buttons" class="space-y-2">
                    <button data-value="suma-simple" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Suma Simple</button>
                    <button data-value="suma-llevada" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-blue-600 text-white shadow-md">Suma con Llevada<span class="check-icon">&#10003;</span></button>
                    <button data-value="resta-simple" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Resta Simple</button>
                    <button data-value="resta-llevada" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Resta con Llevada</button>
                    <button data-value="multiplicacion" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Multiplicaci√≥n</button>
                    <button data-value="series" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Series</button>
                    <button data-value="pyramid" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Pir√°mides Matem√°ticas</button>
                    <button data-value="tabla-numerica" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Tabla Num√©rica</button>
                    <button data-value="diana-multiplicaciones" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Diana Multiplicaciones</button>
                </div>
            </div>

            <!-- Columna 2: N√∫mero de D√≠gitos y Cantidad de Problemas -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">2. N√∫mero de D√≠gitos</h3>
                <div id="digit-buttons" class="flex space-x-2 mb-6">
                   <button data-value="1" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">1 d√≠gito</button>
                   <button data-value="2" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">2 d√≠gitos</button>
                   <button data-value="3" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">3 d√≠gitos</button>
                </div>

                <h3 class="font-bold text-lg mb-3 text-gray-700">3. Cantidad de Problemas</h3>
                <div id="num-problems-buttons" class="grid grid-cols-2 gap-2">
                    <button data-value="20" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">20 Problemas</button>
                    <button data-value="30" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">30 Problemas</button>
                    <button data-value="40" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">40 Problemas</button>
                    </div>
            </div>

            <!-- Columna 3: Tablas de Multiplicar, Tipo y Patr√≥n de Serie, Tama√±o de Pir√°mide, Tabla Num√©rica -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">4. Tablas de Multiplicar</h3>
                <div id="multiplication-tables" class="grid grid-cols-5 gap-2 transition-opacity duration-300 opacity-30 mb-6">
                    </div>

                <!-- Secci√≥n: Tipo y Patr√≥n de la Serie -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">5. Tipo y patr√≥n de la serie</h3>
                <div id="series-controls-wrapper" class="transition-opacity duration-300 opacity-30">
                    <!-- Checkbox para Patr√≥n y Direcci√≥n Aleatorios -->
                    <div class="mb-4 flex items-center">
                        <input type="checkbox" id="random-series-checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mr-2">
                        <label for="random-series-checkbox" class="text-gray-700 text-sm font-medium">Patr√≥n y Direcci√≥n Aleatorios</label>
                    </div>

                    <!-- Slider para Rango de Inicio para Series -->
                    <div id="series-start-range-slider-container" class="transition-opacity duration-300 opacity-30 mb-6">
                        <label for="series-start-range-slider" class="block text-sm font-medium text-gray-700 mb-2">Valores de inicio hasta: <span id="series-start-range-label" class="font-bold text-blue-600">99</span></label>
                        <input type="range" id="series-start-range-slider" min="0" max="9" step="1" value="9" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    </div>

                    <!-- Botones de direcci√≥n de series -->
                    <div id="series-direction-buttons" class="grid grid-cols-2 gap-2 mb-6">
                        </div>
                    <!-- Botones del patr√≥n num√©rico -->
                    <div id="series-pattern-buttons" class="grid grid-cols-5 gap-2">
                        </div>
                </div>

                <!-- Nueva Secci√≥n: Tama√±o de la Pir√°mide -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">6. Tama√±o de la Pir√°mide</h3>
                <div id="pyramid-size-buttons" class="grid grid-cols-3 gap-2 transition-opacity duration-300 opacity-30">
                    <button data-value="2-1" class="pyramid-size-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">2-1</button>
                    <button data-value="4-2-1" class="pyramid-size-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">4-2-1</button>
                    </div>

                <!-- Nueva Secci√≥n: Opciones de Tabla Num√©rica -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">7. Opciones de Tabla Num√©rica</h3>
                <div id="tabla-numerica-controls" class="grid grid-cols-1 gap-2 transition-opacity duration-300 opacity-30">
                    <button data-value="1-100" class="tabla-numerica-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">N√∫meros 1-100</button>
                    <button data-value="pitagorica" class="tabla-numerica-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">Tabla Pitag√≥rica</button>
                </div>
            </div>
        </div>

        <!-- Botones de Acci√≥n -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
            <button id="generate-btn" class="w-full sm:w-auto px-8 py-3 bg-green-600 text-white font-bold rounded-xl shadow-lg hover:bg-green-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Generar Nueva Hoja</button>
            <button id="download-btn" class="w-full sm:w-auto px-8 py-3 bg-red-600 text-white font-bold rounded-xl shadow-lg hover:bg-red-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Descargar PDF</button>
            <button id="download-answers-btn" class="w-full sm:w-auto px-8 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-lg hover:bg-indigo-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Descargar Respuestas</button>
        </div>

        <!-- CONTENEDOR DE EXPORTACI√ìN (AQU√ç SALE EL PDF) -->
        <div id="preview-container" class="mb-8">
            <div id="worksheet">
                <!-- Modificado: Alineaci√≥n de elementos en el encabezado a 'items-start' -->
                <div class="flex items-start gap-4 mb-2"> 
                    <div class="ascii-logo" aria-hidden="true">
                        <pre style="margin:0; font-family: 'Courier New', Courier, monospace; font-size: 1.0rem; display:inline-block; text-align:left;">
‚ïî‚ïê‚ï¶‚ïê‚ï¶‚ïê
‚ï†‚ïê‚ï¨‚ïê‚ï¨‚ïê
‚ïö‚ïê‚ïù</pre>
                    </div>
                    <h2 class="worksheet-title">Hoja de Matem√°ticas</h2>
                </div>
                <div class="worksheet-name-container">
                    <span class="worksheet-name-label">Nombre:</span>
                    <span class="worksheet-name-line"></span>
                </div>
                <div id="problems-container" class="grid grid-cols-5 gap-x-8 gap-y-12"></div>
            </div>
        </div>
        
        <footer class="text-center mt-8 text-gray-500 text-sm">
            <p>Dise√±ado por AFB para ayudar en el aprendizaje de las matem√°ticas.</p>
        </footer>
    </div>

    <!-- Modales/overlays igual que antes... -->
    <div id="alert-modal" class="modal-backdrop">
        <div class="modal-content">
            <p id="alert-message" class="mb-4 text-lg"></p>
            <button id="alert-close-btn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">Cerrar</button>
        </div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <span class="loading-icon">üïí</span>
            <p class="text-xl font-semibold text-gray-700">Generando PDF...</p>
            <p class="text-sm text-gray-500">Esto puede tardar unos segundos.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Estado de la aplicaci√≥n
            let state = {
                operation: 'suma-llevada', // Operaci√≥n predeterminada al cargar
                digits: '2', // D√≠gitos predeterminados
                numProblems: 30, // Cantidad de problemas predeterminada (cambiado de 50 a 30)
                tables: new Array(10).fill(true), // Tablas de multiplicar seleccionadas (1-10)
                seriesPatterns: [true, false, false, false, false, false, false, false, false, false], // Patrones de series (1-10), predefinido a +1
                seriesDirections: ['progresiva'], // Direcci√≥n de series ('progresiva', 'regresiva'), predefinido a progresiva
                randomSeriesMode: false, // Modo aleatorio para series (patr√≥n y direcci√≥n por paso)
                seriesStartMaxDecade: 9, // M√°xima d√©cada para el n√∫mero de inicio de series (0-9, representando 0s-90s)
                pyramidSize: '2-1', // Nuevo: Tama√±o de la pir√°mide
                tablaNumericaType: '1-100', // Nuevo: Tipo de tabla num√©rica ('1-100', 'pitagorica')
                problems: [] // Almacena los problemas generados, incluyendo sus respuestas
            };

            // Elementos del DOM
            const operationButtonsContainer = document.getElementById('operation-buttons');
            const digitButtonsContainer = document.getElementById('digit-buttons');
            const numProblemsButtonsContainer = document.getElementById('num-problems-buttons');
            const multiplicationTablesContainer = document.getElementById('multiplication-tables');
            const seriesControlsWrapper = document.getElementById('series-controls-wrapper');
            const randomSeriesCheckbox = document.getElementById('random-series-checkbox');
            const seriesPatternButtonsContainer = document.getElementById('series-pattern-buttons');
            const seriesDirectionButtonsContainer = document.getElementById('series-direction-buttons');
            const seriesStartRangeSliderContainer = document.getElementById('series-start-range-slider-container'); // Contenedor del slider
            const seriesStartRangeSlider = document.getElementById('series-start-range-slider'); // El slider en s√≠
            const seriesStartRangeLabel = document.getElementById('series-start-range-label'); // Etiqueta del slider
            const pyramidSizeButtonsContainer = document.getElementById('pyramid-size-buttons'); // Nuevo
            const tablaNumericaControls = document.getElementById('tabla-numerica-controls'); // Nuevo
            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');
            const downloadAnswersBtn = document.getElementById('download-answers-btn');
            const problemsContainer = document.getElementById('problems-container');
            const worksheet = document.getElementById('worksheet');
            const worksheetTitleElement = document.querySelector('.worksheet-title'); // Ahora es una clase
            const previewContainer = document.getElementById('preview-container'); // Nuevo

            // Elementos del Modal
            const alertModal = document.getElementById('alert-modal');
            const alertMessage = document.getElementById('alert-message');
            const alertCloseBtn = document.getElementById('alert-close-btn');

            // Elementos del Overlay de carga
            const loadingOverlay = document.getElementById('loading-overlay');

            const checkIconSvg = `<span class="check-icon">&#10003;</span>`;
            
            downloadBtn.disabled = false;
            downloadAnswersBtn.disabled = false;
            
            // --- Funciones de L√≥gica ---
            const getRandomNumberByDigits = (numDigits) => {
                if (numDigits === 1) return Math.floor(Math.random() * 9) + 1; // 1-9 for regular ops
                const min = Math.pow(10, numDigits - 1);
                const max = Math.pow(10, numDigits) - 1;
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };

            const getDigitsArray = (num) => String(num).split('').map(Number);
            
            const isSimpleSum = (n1, n2) => {
                const d1 = getDigitsArray(n1).reverse();
                const d2 = getDigitsArray(n2).reverse();
                const len = Math.max(d1.length, d2.length);
                for (let i = 0; i < len; i++) {
                    if (((d1[i] || 0) + (d2[i] || 0)) >= 10) return false;
                }
                return true;
            };

            const isCarrySum = (n1, n2) => !isSimpleSum(n1, n2);
            
            const isSimpleSub = (n1, n2) => {
                const d1 = getDigitsArray(n1).reverse();
                const d2 = getDigitsArray(n2).reverse();
                if (n1 < n2) return false;

                for (let i = 0; i < d2.length; i++) {
                    if (d1[i] < d2[i]) return false;
                }
                return true;
            };

            const isCarrySub = (n1, n2) => (n1 >= n2) && !isSimpleSub(n1, n2);

            const generatePyramidNumbers = (baseCount, maxOverallPyramidValue, maxBaseNumberValue = null) => {
                let pyramid = [];
                let baseNumbers = [];
                let valid = false; 
                let attemptsToFindValidPyramid = 0;
                const maxAttemptsToFindValidPyramid = 500; 

                while (!valid && attemptsToFindValidPyramid < maxAttemptsToFindValidPyramid) {
                    baseNumbers = []; 
                    let zeroCount = 0; 
                    let currentPyramidBaseIsValid = true; 

                    let attemptsPerBase = 0;
                    const maxAttemptsPerBase = 100;

                    for (let i = 0; i < baseCount; i++) {
                        let num;
                        let innerNumAttempts = 0;
                        const maxInnerNumAttempts = 50; 
                        const currentMaxValForGeneration = maxBaseNumberValue !== null ? maxBaseNumberValue : maxOverallPyramidValue;

                        do {
                            num = Math.floor(Math.random() * (currentMaxValForGeneration + 1));

                            const minValForDigits = (parseInt(state.digits) === 1) ? 0 : Math.pow(10, parseInt(state.digits) - 1);
                            
                            if ( (num === 0 && zeroCount >= 1) || 
                                 (num < minValForDigits && num !== 0 && parseInt(state.digits) !== 1) ||
                                 (num > currentMaxValForGeneration) )
                            {
                                innerNumAttempts++;
                                continue;
                            }
                            
                            if (num === 0) {
                                zeroCount++;
                            }
                            break; 
                        } while (innerNumAttempts < maxInnerNumAttempts);

                        if (innerNumAttempts >= maxInnerNumAttempts) {
                            currentPyramidBaseIsValid = false; 
                            break;
                        }
                        baseNumbers.push(num);
                    }

                    if (!currentPyramidBaseIsValid || zeroCount > 1) { 
                        attemptsToFindValidPyramid++;
                        continue; 
                    }

                    pyramid = [baseNumbers];
                    let currentLayer = baseNumbers;
                    let allLayersValid = true;

                    while (currentLayer.length > 1) {
                        let nextLayer = [];
                        for (let i = 0; i < currentLayer.length - 1; i++) {
                            let sum = currentLayer[i] + currentLayer[i+1];
                            if (sum > maxOverallPyramidValue || sum < 0) {
                                allLayersValid = false;
                                break;
                            }
                            nextLayer.push(sum);
                        }
                        if (!allLayersValid) break;
                        pyramid.push(nextLayer);
                        currentLayer = nextLayer;
                    }

                    if (allLayersValid) {
                        valid = true; 
                    } else {
                        attemptsToFindValidPyramid++; 
                    }
                }
                
                return valid ? pyramid : null; 
            };


            // --- Funci√≥n para mostrar alertas personalizadas ---
            const showAlert = (message) => {
                alertMessage.textContent = message;
                alertModal.classList.add('visible');
            };

            // --- Funci√≥n para ocultar la alerta ---
            const hideAlert = () => {
                alertModal.classList.remove('visible');
            };

            // --- Funciones para mostrar/ocultar el overlay de carga ---
            const showLoading = (message = "Generando PDF...", subMessage = "Esto puede tardar unos segundos.") => {
                loadingOverlay.querySelector('p:first-of-type').textContent = message;
                loadingOverlay.querySelector('p:last-of-type').textContent = subMessage;
                loadingOverlay.classList.add('visible');
            };

            const hideLoading = () => {
                // Solo oculta el overlay de carga, no el modal de alerta
                loadingOverlay.classList.remove('visible');
            };

            // Helper for generateSeries
            const getRandomElement = (arr) => arr[Math.floor(Math.random() * arr.length)];

            /**
             * Generates a numeric series based on state configuration.
             * @param {Object} seriesState - Configuration state relevant to series generation
             * @param {boolean} seriesState.randomSeriesMode - If true, choose pattern and direction randomly
             * @param {number[]} seriesState.seriesPatterns - Selected patterns (as numbers), e.g. [1, 2]
             * @param {string[]} seriesState.seriesDirections - Selected directions, e.g. ['progresiva','regresiva']
             * @param {string} seriesState.digits - '1' or '2'
             * @param {number} seriesState.seriesStartMaxDecade - Starting decade (0‚Äì9)
             * @param {number} [numSquares=6] - Number of elements in series
             * @param {number} [maxAttempts=1000] - Number of retry attempts for the whole series
             * @returns {{ series: number[], operations: {direction:string, value:number}[] }}
             */
            function generateSeries(seriesState, numSquares = 6, maxAttempts = 1000) {
                const patterns = seriesState.seriesPatterns.map((p, idx) => p ? (idx + 1) : null).filter(val => val !== null);
                const directions = seriesState.seriesDirections;
                const randomMode = seriesState.randomSeriesMode;

                const digits = parseInt(seriesState.digits, 10);
                const minValForDigits = (digits === 1 ? 0 : Math.pow(10, digits - 1));
                const maxValForDigits = Math.min(Math.pow(10, digits) - 1, 99); // Max value is 99 for 2 digits

                const decadeMin = seriesState.seriesStartMaxDecade * 10;
                const decadeMax = Math.min(decadeMin + 9, maxValForDigits);

                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const series = [];
                    const operations = [];

                    let start;
                    let startAttempts = 0;
                    const maxStartAttempts = 50;
                    do {
                        start = decadeMin + Math.floor(Math.random() * (decadeMax - decadeMin + 1));
                        startAttempts++;
                    } while ((start < minValForDigits || start > maxValForDigits) && startAttempts < maxStartAttempts);

                    if (startAttempts >= maxStartAttempts) {
                        continue;
                    }

                    let current = start;
                    series.push(current);

                    let valid = true;
                    for (let i = 1; i < numSquares; i++) {
                        let stepPatternCandidate, stepDirectionCandidate;
                        let foundValidStep = false;
                        const maxStepAttempts = 20; // Max attempts to find a valid next step for current 'current' number

                        for (let stepAttempt = 0; stepAttempt < maxStepAttempts; stepAttempt++) {
                            if (randomMode) {
                                stepPatternCandidate = Math.floor(Math.random() * 10) + 1;
                                stepDirectionCandidate = Math.random() < 0.5 ? 'progresiva' : 'regresiva';
                            } else {
                                if (patterns.length === 0) {
                                    stepPatternCandidate = 2; // Defaults to +2 if no patterns selected
                                } else {
                                    stepPatternCandidate = getRandomElement(patterns); // Use the already mapped and filtered patterns
                                }

                                if (directions.length === 1) {
                                    stepDirectionCandidate = directions[0];
                                } else {
                                    stepDirectionCandidate = Math.random() < 0.5 ? 'progresiva' : 'regresiva';
                                }
                            }

                            let nextCandidate = stepDirectionCandidate === 'progresiva' ? current + stepPatternCandidate : current - stepPatternCandidate;

                            if (nextCandidate >= minValForDigits && nextCandidate <= maxValForDigits) {
                                series.push(nextCandidate);
                                operations.push({ direction: stepDirectionCandidate, value: stepPatternCandidate });
                                current = nextCandidate;
                                foundValidStep = true;
                                break; 
                            }
                        }

                        if (!foundValidStep) {
                            valid = false; 
                            break; 
                        }
                    }

                    if (valid && series.length === numSquares) {
                        return { series, operations };
                    }
                }

                throw new Error('No se pudo generar una serie v√°lida con los criterios seleccionados.');
            }


            // --- Generaci√≥n de Problemas ---
            const generateProblems = () => {
                hideAlert(); // Ocultar cualquier alerta existente al iniciar la generaci√≥n
                showLoading("Generando problemas..."); // Mostrar el indicador de carga

                const newProblems = [];
                let attempts = 0;
                const maxAttempts = 5000;
                
                let totalProblemsToGenerate;
                if (state.operation === 'series') {
                    totalProblemsToGenerate = 8; // Fixed to 8 series problems for one page
                } else if (state.operation === 'tabla-numerica') {
                    totalProblemsToGenerate = 1; // Tabla num√©rica siempre es 1
                } else if (state.operation === 'pyramid') {
                    if (state.pyramidSize === '2-1') {
                        totalProblemsToGenerate = 24;
                    } else if (state.pyramidSize === '4-2-1') {
                        totalProblemsToGenerate = 12; 
                    }
                } else if (state.operation === 'diana-multiplicaciones') { 
                    totalProblemsToGenerate = 6;
                }
                else {
                    totalProblemsToGenerate = state.numProblems;
                }

                let pyramidStructure = null; 

                while (newProblems.length < totalProblemsToGenerate && attempts < maxAttempts) { 
                    let problem = null;

                    switch (state.operation) {
                        case 'suma-simple':
                        case 'suma-llevada':
                        case 'resta-simple':
                        case 'resta-llevada':
                        case 'multiplicacion':
                            const num1 = getRandomNumberByDigits(parseInt(state.digits));
                            let num2 = getRandomNumberByDigits(parseInt(state.digits));
                            
                            if (state.operation === 'multiplicacion') {
                                const selectedTables = state.tables.map((t, i) => t ? i + 1 : null).filter(Boolean);
                                if (selectedTables.length === 0) {
                                    attempts++;
                                    continue;
                                }
                                num2 = selectedTables[Math.floor(Math.random() * selectedTables.length)];
                                problem = { num1, num2, operator: '√ó', answer: num1 * num2 };
                            } else {
                                let currentNum1, currentNum2;
                                let conditionMet = false;
                                let innerAttempts = 0;
                                const maxInnerAttempts = 100;

                                do {
                                    currentNum1 = getRandomNumberByDigits(parseInt(state.digits));
                                    currentNum2 = getRandomNumberByDigits(parseInt(state.digits));
                                    
                                    if (state.operation === 'suma-simple') conditionMet = isSimpleSum(currentNum1, currentNum2);
                                    else if (state.operation === 'suma-llevada') conditionMet = isCarrySum(currentNum1, currentNum2);
                                    else if (state.operation === 'resta-simple') conditionMet = isSimpleSub(currentNum1, currentNum2);
                                    else if (state.operation === 'resta-llevada') conditionMet = isCarrySub(currentNum1, currentNum2);
                                    innerAttempts++;
                                } while (!conditionMet && innerAttempts < maxInnerAttempts);

                                if (conditionMet) {
                                    if (state.operation.startsWith('resta')) {
                                        problem = { num1: Math.max(currentNum1, currentNum2), num2: Math.min(currentNum1, currentNum2), operator: '‚àí', answer: Math.max(currentNum1, currentNum2) - Math.min(currentNum1, currentNum2) };
                                    } else {
                                        problem = { num1: currentNum1, num2: currentNum2, operator: '+', answer: currentNum1 + currentNum2 };
                                    }
                                }
                            }
                            break;

                        case 'series':
                            const numSquaresSeries = 6; // Number of elements in series
                            const maxAttemptsToGenerateSeries = 1000;

                            // Adjust state for series generation if needed (e.g., digits 3 not supported)
                            if (parseInt(state.digits) === 3) {
                                state.digits = '2';
                                updateDigitControls(); // Update UI if state changed
                            }
                            if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                                state.seriesStartMaxDecade = 1;
                                updateSeriesStartRangeSlider(); // Update UI if state changed
                            }

                            try {
                                const { series, operations } = generateSeries({
                                    randomSeriesMode: state.randomSeriesMode,
                                    seriesPatterns: state.seriesPatterns, // Pass the raw boolean array, mapping done in generateSeries
                                    seriesDirections: state.seriesDirections,
                                    digits: state.digits,
                                    seriesStartMaxDecade: state.seriesStartMaxDecade
                                }, numSquaresSeries, maxAttemptsToGenerateSeries);

                                problem = {
                                    type: 'series',
                                    series: series,
                                    stepOperations: operations.map(op => ({ operator: op.direction === 'progresiva' ? '+' : '‚àí', value: op.value })),
                                    answer: series
                                };
                            } catch (error) {
                                console.warn("No se pudo generar la serie:", error.message);
                                // Si no se puede generar una serie, 'problem' permanece nulo, y el bucle exterior reintenta.
                                // Esto evita mostrar una alerta por cada intento fallido durante la generaci√≥n.
                            }
                            break;
                        
                        case 'pyramid':
                            let maxOverallPyramidValue;
                            let maxBaseNumberValue = null; 

                            if (parseInt(state.digits) === 1) {
                                maxOverallPyramidValue = 72;
                                maxBaseNumberValue = 9;
                            } else if (parseInt(state.digits) === 2) {
                                maxOverallPyramidValue = 99; 
                                maxBaseNumberValue = 5; 
                            }
                            
                            let baseCountPyramid;
                            if (state.pyramidSize === '2-1') baseCountPyramid = 2;
                            else if (state.pyramidSize === '4-2-1') baseCountPyramid = 4;

                            pyramidStructure = generatePyramidNumbers(baseCountPyramid, maxOverallPyramidValue, maxBaseNumberValue);

                            if (pyramidStructure) {
                                problem = {
                                    type: 'pyramid',
                                    pyramid: pyramidStructure,
                                    answer: pyramidStructure[pyramidStructure.length - 1][0]
                                };
                            }
                            break;

                        case 'tabla-numerica':
                            if (state.tablaNumericaType === '1-100') {
                                const grid100 = Array.from({ length: 10 }, (_, r) => 
                                    Array.from({ length: 10 }, (_, c) => (r * 10) + c + 1)
                                );
                                const prefilledCells = [];
                                const usedRows = new Set();
                                const numPrefilled = 10; 

                                let attemptsToFill = 0;
                                const maxAttemptsToFill = 100;

                                while (prefilledCells.length < numPrefilled && attemptsToFill < maxAttemptsToFill) {
                                    let randomRow;
                                    let rowFound = false;
                                    let rowAttempt = 0;
                                    const maxRowAttempts = 20;

                                    do {
                                        randomRow = Math.floor(Math.random() * 10);
                                        if (!usedRows.has(randomRow)) {
                                            rowFound = true;
                                            usedRows.add(randomRow);
                                        }
                                        rowAttempt++;
                                    } while (!rowFound && rowAttempt < maxRowAttempts);

                                    if (!rowFound) {
                                        console.warn("No se pudo encontrar una fila √∫nica para las celdas pre-rellenadas.");
                                        break; 
                                    }

                                    const randomCol = Math.floor(Math.random() * 10); 
                                    const value = grid100[randomRow][randomCol];
                                    prefilledCells.push({ row: randomRow, col: randomCol, value: value });
                                    attemptsToFill++;
                                }
                                problem = {
                                    type: 'tabla-numerica',
                                    subType: '1-100',
                                    grid: grid100,
                                    prefilledCells: prefilledCells, 
                                    answer: grid100
                                };
                            } else if (state.tablaNumericaType === 'pitagorica') {
                                const gridPitagorica = Array.from({ length: 10 }, (_, r) => 
                                    Array.from({ length: 10 }, (_, c) => (r + 1) * (c + 1))
                                );
                                problem = {
                                    type: 'tabla-numerica',
                                    subType: 'pitagorica',
                                    grid: gridPitagorica,
                                    answer: gridPitagorica
                                };
                            }
                            break;
                        
                        case 'diana-multiplicaciones':
                            const selectedTables = state.tables.map((t, i) => t ? i + 1 : null).filter(Boolean);
                            if (selectedTables.length === 0) {
                                showAlert("Por favor, selecciona al menos una tabla de multiplicar para las Dianas.");
                                return;
                            }
                            const tableNumber = selectedTables[Math.floor(Math.random() * selectedTables.length)];
                            problem = { type: 'diana-multiplicaciones', tableNumber: tableNumber };
                            break;
                    }
                    
                    if (problem) {
                        newProblems.push(problem);
                    }
                    attempts++;
                }

                if (newProblems.length === 0 && attempts >= maxAttempts) {
                    let errorMessage = "No se pudieron generar problemas con los criterios seleccionados. Intenta con otros ajustes.";
                    if (state.operation === 'multiplicacion' && state.tables.filter(Boolean).length === 0) {
                        errorMessage = "Por favor, selecciona al menos una tabla de multiplicar.";
                    } else if (state.operation === 'series' && state.seriesPatterns.filter(Boolean).length === 0 && !state.randomSeriesMode) {
                        errorMessage = "Por favor, selecciona al menos un patr√≥n de serie o activa el modo aleatorio.";
                    } else if (state.operation === 'series' && state.seriesDirections.filter(Boolean).length === 0 && !state.randomSeriesMode) {
                        errorMessage = "Por favor, selecciona al menos una direcci√≥n para las series (Progresiva o Regresiva) o activa el modo aleatorio.";
                    } else if (state.operation === 'pyramid' && !pyramidStructure) {
                         errorMessage = `No se pudieron generar pir√°mides del tama√±o ${state.pyramidSize} con n√∫meros de ${state.digits} d√≠gitos.`;
                    }
                    showAlert(errorMessage);
                }
                state.problems = newProblems; 
                renderProblems(newProblems);
                hideLoading(); // Ocultar el indicador de carga al finalizar la generaci√≥n o mostrar la alerta
            };
            
            // --- Renderizado ---
            const renderProblems = (problems, showAnswers = false) => {
                problemsContainer.innerHTML = '';
                
                problemsContainer.style.display = '';
                problemsContainer.style.flexDirection = '';
                problemsContainer.style.gap = '';
                problemsContainer.style.gridTemplateColumns = '';

                problemsContainer.classList.remove('problems-container-normal', 'problems-container-series');

                if (state.operation === 'series') {
                    problemsContainer.classList.add('problems-container-series'); 
                } else if (state.operation === 'pyramid') {
                    problemsContainer.style.display = 'grid';
                    problemsContainer.style.gap = '2.0rem'; /* Reducido */
                    if (state.pyramidSize === '4-2-1') { 
                        problemsContainer.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
                    } else if (state.pyramidSize === '2-1') {
                        problemsContainer.style.gridTemplateColumns = 'repeat(4, minmax(0, 1fr))';
                    }
                } else if (state.operation === 'tabla-numerica') {
                    problemsContainer.style.display = 'flex';
                    problemsContainer.style.flexDirection = 'column';
                    problemsContainer.style.gap = '0.8rem'; /* Reducido */
                } else if (state.operation === 'diana-multiplicaciones') {
                    problemsContainer.style.display = 'grid';
                    problemsContainer.style.gridTemplateColumns = 'repeat(2, minmax(0, 1fr))';
                    problemsContainer.style.gap = '0.8rem'; /* Reducido */
                }
                else {
                    problemsContainer.classList.add('problems-container-normal'); 
                }

                if (problems.length === 0) {
                    problemsContainer.innerHTML = `<div class="col-span-full text-center py-16 text-gray-500">
                        <p>¬°Genera una hoja de trabajo para empezar!</p>
                        <p class="text-sm mt-2">Usa los controles de arriba y haz clic en "Generar Nueva Hoja".</p>
                    </div>`;
                    return;
                }

                problems.forEach((p, index) => {
                    const problemEl = document.createElement('div');
                    if (p.type === 'series') {
                        problemEl.className = 'series-problem w-full'; 

                        const firstNumSpan = document.createElement('span');
                        firstNumSpan.className = 'series-number-box';
                        firstNumSpan.textContent = p.series[0];
                        problemEl.appendChild(firstNumSpan);

                        p.stepOperations.forEach((stepOp, i) => {
                            const arrowSpan1 = document.createElement('span');
                            arrowSpan1.className = 'series-arrow';
                            arrowSpan1.textContent = ' ‚Üí '; 
                            problemEl.appendChild(arrowSpan1);

                            const patternOpSpan = document.createElement('span');
                            patternOpSpan.className = 'series-pattern-op';
                            patternOpSpan.textContent = `${stepOp.operator}${stepOp.value}`;
                            problemEl.appendChild(patternOpSpan);
                            
                            const arrowSpan2 = document.createElement('span');
                            arrowSpan2.className = 'series-arrow';
                            arrowSpan2.textContent = ' ‚Üí '; 
                            problemEl.appendChild(arrowSpan2);

                            const nextNumSpan = document.createElement('span');
                            nextNumSpan.className = 'series-number-box';
                            if (showAnswers) {
                                nextNumSpan.textContent = p.series[i + 1];
                            } else {
                                nextNumSpan.textContent = ''; 
                            }
                            problemEl.appendChild(nextNumSpan);
                        });

                    } else if (p.type === 'pyramid') {
                        problemEl.className = 'pyramid-problem w-full';
                        const reversedPyramid = [...p.pyramid].reverse();

                        reversedPyramid.forEach((layer, layerIndex) => {
                            const layerDiv = document.createElement('div');
                            layerDiv.className = 'pyramid-layer';
                            
                            layer.forEach((num, numIndex) => {
                                const numSpan = document.createElement('span');
                                numSpan.className = 'pyramid-number-box';
                                
                                if (showAnswers || layerIndex === reversedPyramid.length - 1) {
                                    numSpan.textContent = num;
                                } else {
                                    numSpan.textContent = '';
                                    numSpan.classList.add('empty');
                                }
                                layerDiv.appendChild(numSpan);
                            });
                            problemEl.appendChild(layerDiv);
                        });

                    } else if (p.type === 'tabla-numerica') { 
                        problemEl.className = 'w-full h-full flex justify-center';

                        if (p.subType === '1-100') {
                            const gridContainer = document.createElement('div');
                            gridContainer.className = 'number-grid-container';
                            
                            p.grid.forEach((row, rowIndex) => {
                                const rowDiv = document.createElement('div');
                                rowDiv.className = 'number-grid-row';
                                row.forEach((cellValue, colIndex) => {
                                    const cellDiv = document.createElement('div');
                                    cellDiv.className = 'number-grid-cell';
                                    
                                    const prefilled = p.prefilledCells.some(c => c.row === rowIndex && c.col === colIndex);
                                    if (prefilled) {
                                        cellDiv.textContent = cellValue;
                                        cellDiv.classList.add('prefilled');
                                    } else {
                                        const input = document.createElement('input');
                                        input.type = 'number';
                                        input.min = '1';
                                        input.max = '100';
                                        input.readOnly = showAnswers;
                                        if (showAnswers) {
                                            input.value = cellValue;
                                        }
                                        cellDiv.appendChild(input);
                                    }
                                    rowDiv.appendChild(cellDiv);
                                });
                                gridContainer.appendChild(rowDiv);
                            });
                            problemEl.appendChild(gridContainer);

                        } else if (p.subType === 'pitagorica') {
                            const pitagoricaWrapper = document.createElement('div');
                            pitagoricaWrapper.className = 'pitagorica-grid-wrapper';

                            const fullGridDiv = document.createElement('div');
                            fullGridDiv.className = 'pitagorica-full-grid';

                            // Celda de la esquina (X)
                            const emptyCorner = document.createElement('div');
                            emptyCorner.className = 'pitagorica-header-cell empty-corner';
                            emptyCorner.textContent = '√ó';
                            fullGridDiv.appendChild(emptyCorner);

                            // Encabezados superiores (1-10)
                            for (let i = 1; i <= 10; i++) {
                                const headerCell = document.createElement('div');
                                headerCell.className = 'pitagorica-header-cell';
                                headerCell.textContent = i;
                                fullGridDiv.appendChild(headerCell);
                            }

                            // Encabezados laterales (1-10) y celdas de la cuadr√≠cula principal
                            for (let r = 0; r < 10; r++) { // 10 filas para encabezados laterales y cuadr√≠cula principal
                                // Celda de encabezado lateral
                                const sideHeaderCell = document.createElement('div');
                                sideHeaderCell.className = 'pitagorica-header-cell';
                                sideHeaderCell.textContent = r + 1;
                                fullGridDiv.appendChild(sideHeaderCell);

                                // Celdas de la cuadr√≠cula principal (10 columnas por fila)
                                for (let c = 0; c < 10; c++) {
                                    const cellDiv = document.createElement('div');
                                    cellDiv.className = 'number-grid-cell';
                                    const input = document.createElement('input');
                                    input.type = 'number';
                                    input.readOnly = showAnswers;
                                    if (showAnswers) {
                                        input.value = p.grid[r][c];
                                    }
                                    cellDiv.appendChild(input);
                                    fullGridDiv.appendChild(cellDiv);
                                }
                            }
                            pitagoricaWrapper.appendChild(fullGridDiv);
                            problemEl.appendChild(pitagoricaWrapper);
                        }

                    } else if (p.type === 'diana-multiplicaciones') {
                        problemEl.className = 'diana-multiplicaciones-problem';

                        const centerDiv = document.createElement('div');
                        centerDiv.className = 'diana-center';
                        centerDiv.textContent = `${p.tableNumber}x`;
                        problemEl.appendChild(centerDiv);

                        const innerRingDiv = document.createElement('div');
                        innerRingDiv.className = 'diana-ring inner';
                        problemEl.appendChild(innerRingDiv);

                        const outerRingDiv = document.createElement('div');
                        outerRingDiv.className = 'diana-ring outer';
                        // Aplica el fondo conic-gradient directamente al anillo exterior para las l√≠neas
                        outerRingDiv.style.background = `conic-gradient(transparent 0deg 17deg, black 17deg 18deg, transparent 18deg 35deg, black 35deg 36deg, transparent 36deg 53deg, black 53deg 54deg, transparent 54deg 71deg, black 71deg 72deg, transparent 72deg 89deg, black 89deg 90deg, transparent 90deg 107deg, black 107deg 108deg, transparent 108deg 125deg, black 125deg 126deg, transparent 126deg 143deg, black 143deg 144deg, transparent 144deg 161deg, black 161deg 162deg, transparent 162deg 179deg, black 179deg 180deg, transparent 180deg 197deg, black 197deg 198deg, transparent 198deg 215deg, black 215deg 216deg, transparent 216deg 233deg, black 233deg 234deg, transparent 234deg 251deg, black 251deg 252deg, transparent 252deg 269deg, black 269deg 270deg, transparent 270deg 287deg, black 287deg 288deg, transparent 288deg 305deg, black 305deg 306deg, transparent 306deg 323deg, black 323deg 324deg, transparent 324deg 341deg, black 341deg 342deg, transparent 342deg 359deg, black 359deg 360deg)`;
                        outerRingDiv.style.opacity = '0.5'; // Aplica opacidad directamente
                        outerRingDiv.style.zIndex = '0'; // Aseg√∫rate de que est√© detr√°s de otros elementos
                        problemEl.appendChild(outerRingDiv);

                        const numItems = 10;
                        // Actualiza innerRadius y outerRadius para que coincidan con los nuevos tama√±os de los anillos
                        const innerRadius = 110 / 2; // 110px de ancho -> 55px de radio
                        const outerRadius = 180 / 2; // 180px de ancho -> 90px de radio
                        const angleStep = (2 * Math.PI) / numItems; 

                        for (let i = 0; i < numItems; i++) {
                            const currentAngle = (-Math.PI / 2) + (i * angleStep); 

                            const numDiv = document.createElement('div');
                            numDiv.className = `diana-ring-item diana-number`;
                            numDiv.textContent = i + 1;

                            const numX = innerRadius + innerRadius * Math.cos(currentAngle);
                            const numY = innerRadius + innerRadius * Math.sin(currentAngle); 

                            numDiv.style.left = `${numX}px`;
                            numDiv.style.top = `${numY}px`;
                            numDiv.style.transform = 'translate(-50%, -50%)';
                            innerRingDiv.appendChild(numDiv);

                            const answerBoxDiv = document.createElement('div');
                            answerBoxDiv.className = `diana-ring-item diana-answer-box`;
                            const answerInput = document.createElement('input');
                            answerInput.type = 'number';
                            answerInput.readOnly = showAnswers;
                            if (showAnswers) {
                                answerInput.value = (i + 1) * p.tableNumber;
                            }
                            answerBoxDiv.appendChild(answerInput);

                            const ansX = outerRadius + outerRadius * Math.cos(currentAngle);
                            const ansY = outerRadius + outerRadius * Math.sin(currentAngle); 

                            answerBoxDiv.style.left = `${ansX}px`;
                            answerBoxDiv.style.top = `${ansY}px`;
                            answerBoxDiv.style.transform = 'translate(-50%, -50%)';
                            outerRingDiv.appendChild(answerBoxDiv);
                        }
                    } else {
                        problemEl.className = 'problem-math-wrapper';
                        problemEl.innerHTML = `
                            <div class="problem-line">
                                <span class="number-operand-top">${p.num1}</span>
                            </div>
                            <div class="problem-line problem-line-bottom">
                                <span class="operator-operand">${p.operator}</span>
                                <span class="number-operand-bottom">${p.num2}</span>
                            </div>
                            <div class="result-line-display">
                                ${showAnswers ? `<span class="result-number">${p.answer}</span>` : '<span class="empty-result-space"></span>'}
                            </div>
                        `;
                    }
                    problemsContainer.appendChild(problemEl);
                });
            };

            const updateOperationControls = () => {
                operationButtonsContainer.querySelectorAll('button').forEach(btn => {
                    const value = btn.dataset.value;
                    if (value === state.operation) {
                        btn.className = 'control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-blue-600 text-white shadow-md selected';
                        if (!btn.querySelector('.check-icon')) btn.insertAdjacentHTML('beforeend', checkIconSvg);
                    } else {
                           btn.className = 'control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300';
                           const icon = btn.querySelector('.check-icon');
                           if (icon) icon.remove();
                    }
                });
                const isMultiplication = state.operation === 'multiplicacion';
                const isSeries = state.operation === 'series'; 
                const isPyramid = state.operation === 'pyramid';
                const isTablaNumerica = state.operation === 'tabla-numerica';
                const isDianaMultiplicaciones = state.operation === 'diana-multiplicaciones';

                multiplicationTablesContainer.classList.toggle('opacity-30', !(isMultiplication || isDianaMultiplicaciones));
                multiplicationTablesContainer.querySelectorAll('button').forEach(btn => btn.disabled = !(isMultiplication || isDianaMultiplicaciones));

                seriesControlsWrapper.classList.toggle('opacity-30', !isSeries);
                randomSeriesCheckbox.disabled = !isSeries;
                const disableManualSeriesControls = !isSeries || state.randomSeriesMode;
                seriesPatternButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = disableManualSeriesControls);
                seriesDirectionButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = disableManualSeriesControls);
                seriesStartRangeSliderContainer.classList.toggle('opacity-30', !isSeries);
                seriesStartRangeSlider.disabled = !isSeries;
                seriesStartRangeLabel.classList.toggle('text-gray-400', !isSeries);

                pyramidSizeButtonsContainer.classList.toggle('opacity-30', !isPyramid);
                pyramidSizeButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = !isPyramid);

                tablaNumericaControls.classList.toggle('opacity-30', !isTablaNumerica);
                tablaNumericaControls.querySelectorAll('button').forEach(btn => btn.disabled = !isTablaNumerica);

                numProblemsButtonsContainer.closest('div').style.display = (isSeries || isPyramid || isTablaNumerica || isDianaMultiplicaciones) ? 'none' : 'grid'; 
                digitButtonsContainer.closest('div').style.display = (isSeries || isPyramid || isTablaNumerica || isDianaMultiplicaciones) ? 'none' : 'flex';

                // --- L√≥gica de ajuste autom√°tico para series al cambiar la operaci√≥n ---
                if (isSeries) {
                    if (parseInt(state.digits) === 3) {
                        state.digits = '2'; // Forzar a 2 d√≠gitos si estaba en 3
                    }
                    if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                        state.seriesStartMaxDecade = 1;
                    }
                }
                // --- Fin de l√≥gica de ajuste autom√°tico ---

                updateDigitControls(); // Asegurarse de que los controles de d√≠gitos se actualicen
                updateTablaNumericaControls();
                updateSeriesStartRangeSlider(); // Asegurarse de que el slider de series se actualice
            };
            
            const updateDigitControls = () => {
                const isTablaNumericaOperation = state.operation === 'tabla-numerica'; 
                const isDianaMultiplicaciones = state.operation === 'diana-multiplicaciones';
                const isSeriesOperation = state.operation === 'series'; // Nuevo

                digitButtonsContainer.querySelectorAll('button').forEach(btn => {
                    const digitValue = parseInt(btn.dataset.value);
                    const isPyramidOperation = state.operation === 'pyramid';
                    let shouldBeDisabled = false;

                    if (isPyramidOperation) {
                        if (digitValue === 1 && state.pyramidSize === '4-2-1') {
                            shouldBeDisabled = true;
                        }
                        if (digitValue === 2) {
                            shouldBeDisabled = true;
                        }
                        if (digitValue === 3) {
                            shouldBeDisabled = true;
                        }
                    } else if (isTablaNumericaOperation || isDianaMultiplicaciones) {
                        shouldBeDisabled = true;
                    } else if (isSeriesOperation && digitValue === 3) { // Deshabilitar 3 d√≠gitos para series
                        shouldBeDisabled = true;
                    }

                    if (shouldBeDisabled) {
                        btn.disabled = true;
                        btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md', 'bg-gray-200', 'text-gray-800');
                        btn.classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                        // Si el d√≠gito seleccionado actualmente se desactiva, cambiarlo a un valor v√°lido
                        if (parseInt(state.digits) === digitValue) {
                            const availableDigits = Array.from(digitButtonsContainer.querySelectorAll('button'))
                                .filter(b => !b.disabled)
                                .map(b => parseInt(b.dataset.value));
                            if (availableDigits.length > 0) {
                                state.digits = String(availableDigits[0]);
                            } else {
                                state.digits = '1'; // Fallback si no hay d√≠gitos disponibles (no deber√≠a pasar)
                            }
                        }
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                        btn.classList.toggle('bg-blue-600', digitValue === parseInt(state.digits));
                        btn.classList.toggle('text-white', digitValue === parseInt(state.digits));
                        btn.classList.toggle('shadow-md', digitValue === parseInt(state.digits));
                        btn.classList.toggle('bg-gray-200', digitValue !== parseInt(state.digits));
                        btn.classList.toggle('text-gray-800', digitValue !== parseInt(state.digits));
                    }
                });
                digitButtonsContainer.closest('div').style.display = (isTablaNumericaOperation || isDianaMultiplicaciones) ? 'none' : 'flex';
                updateSeriesStartRangeSlider(); // Asegurarse de que el slider de series se actualice despu√©s de cambiar d√≠gitos
            };

            const updateNumProblemsControls = () => {
                numProblemsButtonsContainer.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('bg-blue-600', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('text-white', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('shadow-md', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('bg-gray-200', parseInt(btn.dataset.value) !== state.numProblems);
                    btn.classList.toggle('text-gray-800', btn.dataset.value !== state.problems);
                });
            };

            const renderTableButtons = () => {
                 multiplicationTablesContainer.innerHTML = '';
                 for (let i = 0; i < 10; i++) {
                    const tableBtn = document.createElement('button');
                    tableBtn.textContent = i + 1;
                    tableBtn.dataset.index = i;
                    tableBtn.className = `p-3 rounded-lg text-center transition-colors duration-200 font-medium ${state.tables[i] ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    tableBtn.disabled = !(state.operation === 'multiplicacion' || state.operation === 'diana-multiplicaciones');
                    multiplicationTablesContainer.appendChild(tableBtn);
                 }
            };
            
            const renderSeriesPatternButtons = () => {
                seriesPatternButtonsContainer.innerHTML = '';
                for (let i = 0; i < 10; i++) { 
                    const patternValue = i + 1; 
                    const patternBtn = document.createElement('button');
                    patternBtn.textContent = patternValue;
                    patternBtn.dataset.index = i; 
                    patternBtn.className = `p-3 rounded-lg text-center transition-colors duration-200 font-medium ${state.seriesPatterns[i] && !state.randomSeriesMode ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    patternBtn.disabled = state.operation !== 'series' || state.randomSeriesMode; 
                    seriesPatternButtonsContainer.appendChild(patternBtn);
                }
            };

            const renderSeriesDirectionButtons = () => {
                seriesDirectionButtonsContainer.innerHTML = '';
                const directions = ['progresiva', 'regresiva'];
                const labels = { 'progresiva': 'Progresiva (+)', 'regresiva': 'Regresiva (-)' };

                directions.forEach(direction => {
                    const directionBtn = document.createElement('button');
                    directionBtn.textContent = labels[direction];
                    directionBtn.dataset.value = direction;
                    const isSelected = state.seriesDirections.includes(direction);
                    directionBtn.className = `series-direction-button flex-1 p-3 rounded-lg text-center transition-colors duration-200 text-sm font-medium ${isSelected && !state.randomSeriesMode ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    directionBtn.disabled = state.operation !== 'series' || state.randomSeriesMode; 
                    seriesDirectionButtonsContainer.appendChild(directionBtn);
                });
            };

            const updateSeriesStartRangeSlider = () => {
                const numStepsInSeries = 5; // 6 numbers in series means 5 steps/jumps

                // Always allow slider to go from 0 to 9 decades
                seriesStartRangeSlider.min = 0;
                seriesStartRangeSlider.max = 9;
                
                let suggestedDecade = state.seriesStartMaxDecade; // Start with current state value

                if (state.operation === 'series' && !state.randomSeriesMode) {
                    const activePatterns = state.seriesPatterns.map((p, idx) => p ? (idx + 1) : null).filter(val => val !== null);
                    const activeDirections = state.seriesDirections;

                    if (activePatterns.length === 0 || activeDirections.length === 0) {
                        // If no patterns or directions selected, revert to a default safe range
                        suggestedDecade = (parseInt(state.digits) === 2) ? 9 : 0;
                    } else {
                        let minPossibleDecade = 0; // The lowest decade the slider can go to
                        let maxPossibleDecade = 9; // The highest decade the slider can go to

                        // Logic for progressive series to prevent exceeding 99
                        if (activeDirections.includes('progresiva')) {
                            let highestMinDecadeForProgressive = 0; // We need to satisfy the most restrictive pattern
                            activePatterns.forEach(pattern => {
                                let requiredMinStartValue;
                                // Mapeo personalizado del usuario para series progresivas
                                if (pattern === 10) requiredMinStartValue = 30;
                                else if (pattern === 9) requiredMinStartValue = 40;
                                else if (pattern === 8) requiredMinStartValue = 40; // Corregido: antes era minMinStartValue
                                else if (pattern === 7) requiredMinStartValue = 50;
                                else if (pattern === 6) requiredMinStartValue = 50;
                                else if (pattern === 5) requiredMinStartValue = 60;
                                else if (pattern === 4) requiredMinStartValue = 70;
                                else if (pattern === 3) requiredMinStartValue = 70;
                                else if (pattern === 2) requiredMinStartValue = 70;
                                else if (pattern === 1) requiredMinStartValue = 0; // "cualquiera"

                                highestMinDecadeForProgressive = Math.max(highestMinDecadeForProgressive, Math.floor(requiredMinStartValue / 10));
                            });
                            minPossibleDecade = Math.max(minPossibleDecade, highestMinDecadeForProgressive);
                        }

                        // Logic for regressive series to prevent falling below 0
                        if (activeDirections.includes('regresiva')) {
                            let lowestMaxDecadeForRegressive = 9; // We need to satisfy the most restrictive pattern
                            activePatterns.forEach(pattern => {
                                // Calculate the minimum starting value required to not go below 0
                                // If start is X, then X - (pattern * numStepsInSeries) >= 0
                                // X >= pattern * numStepsInSeries
                                let minStartValueRequired = pattern * numStepsInSeries;
                                // The highest decade we can start from while ensuring minStartValueRequired is met
                                // This means the starting number needs to be at least minStartValueRequired
                                // So, the decade should be at least Math.ceil(minStartValueRequired / 10)
                                let minDecadeForRegressiveStart = Math.ceil(minStartValueRequired / 10);
                                if (minDecadeForRegressiveStart > 9) minDecadeForRegressiveStart = 9; // Cap at 90s if too high

                                lowestMaxDecadeForRegressive = Math.min(lowestMaxDecadeForRegressive, minDecadeForRegressiveStart);
                            });
                            maxPossibleDecade = Math.min(maxPossibleDecade, lowestMaxDecadeForRegressive);
                        }
                        
                        // If both progressive and regressive are selected, find a common ground
                        // This part is complex as the ranges can conflict.
                        // For simplicity, let's take the most restrictive range for the suggested decade.
                        if (activeDirections.includes('progresiva') && activeDirections.includes('regresiva')) {
                            // Si ambos est√°n seleccionados, el rango podr√≠a ser muy peque√±o o inexistente.
                            // Por ahora, priorizaremos el l√≠mite inferior del rango progresivo y el l√≠mite superior del rango regresivo.
                            suggestedDecade = Math.max(minPossibleDecade, Math.min(state.seriesStartMaxDecade, maxPossibleDecade));
                        } else if (activeDirections.includes('progresiva')) {
                            suggestedDecade = Math.max(state.seriesStartMaxDecade, minPossibleDecade); // Asegurarse de que sea al menos el m√≠nimo requerido
                        } else if (activeDirections.includes('regresiva')) {
                            suggestedDecade = Math.min(state.seriesStartMaxDecade, maxPossibleDecade); // Asegurarse de que sea como m√°ximo el m√°ximo permitido
                        }

                        // Asegurarse de que suggestedDecade est√© dentro del m√≠nimo/m√°ximo absoluto del slider
                        suggestedDecade = Math.max(0, Math.min(suggestedDecade, 9)); 
                    }
                } else {
                    // No est√° en modo serie o en modo aleatorio, usa el valor previamente establecido o el predeterminado.
                    if (parseInt(state.digits) === 1) {
                        suggestedDecade = 0;
                    } else if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                        suggestedDecade = 1; // Predeterminado a rango 10-19 para 2 d√≠gitos si actualmente es 0-9
                    }
                }

                // Limita el suggestedDecade final dentro del m√≠nimo/m√°ximo absoluto del slider
                state.seriesStartMaxDecade = Math.max(0, Math.min(suggestedDecade, 9)); 
                seriesStartRangeSlider.value = state.seriesStartMaxDecade; // Actualiza la visualizaci√≥n del slider

                const displayMin = state.seriesStartMaxDecade * 10;
                const displayMax = Math.min(displayMin + 9, (parseInt(state.digits) === 1 ? 9 : 99)); // Limita a 9 o 99
                seriesStartRangeLabel.textContent = `${displayMin} - ${displayMax}`;
            };

            const renderPyramidSizeButtons = () => {
                pyramidSizeButtonsContainer.innerHTML = '';
                const sizes = ['2-1', '4-2-1'];
                sizes.forEach(size => {
                    const sizeBtn = document.createElement('button');
                    sizeBtn.textContent = size;
                    sizeBtn.dataset.value = size;
                    const isSelected = state.pyramidSize === size;
                    sizeBtn.className = `pyramid-size-button p-3 rounded-lg text-center transition-colors duration-200 text-sm font-medium ${isSelected ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`;
                    sizeBtn.disabled = state.operation !== 'pyramid';
                    pyramidSizeButtonsContainer.appendChild(sizeBtn);
                });
            };

            const updateTablaNumericaControls = () => {
                tablaNumericaControls.querySelectorAll('button').forEach(btn => {
                    const value = btn.dataset.value;
                    btn.classList.toggle('bg-blue-600', value === state.tablaNumericaType);
                    btn.classList.toggle('text-white', value === state.tablaNumericaType);
                    btn.classList.toggle('shadow-md', value === state.tablaNumericaType);
                    btn.classList.toggle('bg-gray-200', value !== state.tablaNumericaType);
                    btn.classList.toggle('text-gray-800', value !== state.tablaNumericaType);
                });
            };


            // --- Event Listeners ---
            operationButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button) {
                    state.operation = button.dataset.value;
                    updateOperationControls(); 
                    renderSeriesPatternButtons(); 
                    renderSeriesDirectionButtons(); 
                    updateSeriesStartRangeSlider(); // Llamar despu√©s de posibles ajustes de d√≠gitos
                    renderPyramidSizeButtons();
                    updateTablaNumericaControls();
                    generateProblems(); 
                }
            });

            digitButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && !button.disabled) {
                    state.digits = button.dataset.value;
                    updateDigitControls();
                    generateProblems(); 
                }
            });
            
            numProblemsButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button) {
                    state.numProblems = parseInt(button.dataset.value);
                    updateNumProblemsControls();
                    generateProblems(); 
                }
            });

            multiplicationTablesContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && (state.operation === 'multiplicacion' || state.operation === 'diana-multiplicaciones')) {
                    const index = parseInt(button.dataset.index);
                    state.tables[index] = !state.tables[index];
                    button.classList.toggle('bg-blue-500');
                    button.classList.toggle('text-white');
                    button.classList.toggle('bg-gray-200');
                    button.classList.toggle('text-gray-700');
                    generateProblems();
                }
            });

            seriesPatternButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'series' && !state.randomSeriesMode) { 
                    const index = parseInt(button.dataset.index);
                    state.seriesPatterns[index] = !state.seriesPatterns[index]; 
                    renderSeriesPatternButtons(); 
                    updateSeriesStartRangeSlider(); // Actualiza el slider despu√©s de cambiar el patr√≥n
                    generateProblems();
                }
            });

            seriesDirectionButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'series' && !state.randomSeriesMode) { 
                    const value = button.dataset.value;
                    const index = state.seriesDirections.indexOf(value);
                    if (index > -1) {
                        state.seriesDirections.splice(index, 1); 
                    } else {
                        state.seriesDirections.push(value); 
                    }
                    renderSeriesDirectionButtons(); 
                    generateProblems();
                }
            });

            randomSeriesCheckbox.addEventListener('change', (e) => {
                state.randomSeriesMode = e.target.checked;
                updateOperationControls(); 
                renderSeriesPatternButtons(); 
                renderSeriesDirectionButtons(); 
                updateSeriesStartRangeSlider(); // Actualiza el slider cuando cambia el modo aleatorio
                generateProblems(); 
            });

            seriesStartRangeSlider.addEventListener('input', (e) => {
                state.seriesStartMaxDecade = parseInt(e.target.value);
                updateSeriesStartRangeSlider(); 
                generateProblems(); 
            });

            pyramidSizeButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'pyramid') {
                    state.pyramidSize = button.dataset.value;
                    renderPyramidSizeButtons();
                    generateProblems();
                }
            });

            tablaNumericaControls.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'tabla-numerica') {
                    state.tablaNumericaType = button.dataset.value;
                    updateTablaNumericaControls();
                    generateProblems(); 
                }
            });


            generateBtn.addEventListener('click', () => generateProblems());

            // Funci√≥n para reiniciar el estado a valores predeterminados y generar problemas
            const resetStateAndGenerate = () => {
                state.operation = 'suma-llevada';
                state.digits = '2';
                state.numProblems = 30;
                state.tables = new Array(10).fill(true);
                state.seriesPatterns = [true, false, false, false, false, false, false, false, false, false];
                state.seriesDirections = ['progresiva'];
                state.randomSeriesMode = false;
                state.seriesStartMaxDecade = 9; // Predeterminado para 2 d√≠gitos, patr√≥n +1
                state.pyramidSize = '2-1';
                state.tablaNumericaType = '1-100';
                state.problems = [];

                // Actualiza la UI para reflejar el estado reiniciado
                updateOperationControls();
                updateDigitControls();
                updateNumProblemsControls();
                renderTableButtons();
                renderSeriesPatternButtons();
                renderSeriesDirectionButtons();
                updateSeriesStartRangeSlider();
                renderPyramidSizeButtons();
                updateTablaNumericaControls();
                
                generateProblems(); // Intenta generar con el estado reiniciado
            };

            // Modificado: El bot√≥n de cerrar alerta ahora reinicia la generaci√≥n
            alertCloseBtn.addEventListener('click', () => {
                hideAlert();
                resetStateAndGenerate(); // Reinicia la generaci√≥n de problemas
            });


            const prepareWorksheetForPDF = async (showAnswers) => {
                // Aseg√∫rate de que las fuentes est√©n cargadas antes de capturar el canvas
                await document.fonts.ready;

                const titleMap = {
                    'suma-simple': 'Hoja de Sumas Simples',
                    'suma-llevada': 'Hoja de Sumas con Llevada',
                    'resta-simple': 'Hoja de Restas Simples',
                    'resta-llevada': 'Hoja de Restas con Llevada',
                    'multiplicacion': 'Hoja de Multiplicaciones',
                    'series': 'Hoja de Series Num√©ricas',
                    'pyramid': 'Hoja de Pir√°mides Matem√°ticas',
                    'diana-multiplicaciones': 'Hoja de Diana de Multiplicaciones'
                };

                // Establece el t√≠tulo de la hoja de trabajo bas√°ndose en la operaci√≥n actual
                let worksheetPdfTitle = 'Hoja de Ejercicios de Matem√°ticas';
                if (state.operation === 'tabla-numerica') {
                    if (state.tablaNumericaType === '1-100') {
                        worksheetPdfTitle = 'Hoja de Tabla Num√©rica';
                    } else if (state.tablaNumericaType === 'pitagorica') {
                        worksheetPdfTitle = 'Hoja de Tabla Pitag√≥rica'; // T√≠tulo actualizado para la tabla pitag√≥rica
                    }
                } else {
                    worksheetPdfTitle = titleMap[state.operation] || worksheetPdfTitle;
                }

                if (worksheetTitleElement) {
                    worksheetTitleElement.textContent = worksheetPdfTitle;
                }

                // Almacena los estilos originales de la hoja de trabajo para revertirlos m√°s tarde
                worksheet.originalStyle = worksheet.style.cssText;
                
                // Aplica las dimensiones A4 y el relleno para una renderizaci√≥n PDF consistente
                worksheet.style.width = '210mm'; // Ancho A4
                worksheet.style.maxWidth = '210mm'; // Aseg√∫rate de que no se expanda m√°s all√° del ancho A4
                worksheet.style.padding = '10mm'; // A√±ade relleno para simular los m√°rgenes del PDF
                worksheet.style.boxSizing = 'border-box'; // Aseg√∫rate de que el relleno se incluya en el ancho/alto total
                worksheet.style.aspectRatio = 'auto'; // Anula la relaci√≥n de aspecto para dimensiones fijas
                worksheet.style.overflow = 'visible'; // Crucial: Aseg√∫rate de que todo el contenido se capture, incluso si se desborda inicialmente

                // Oculta los controles y botones de acci√≥n
                const controlsPanel = document.querySelector('.grid-cols-1.lg\\:grid-cols-3.gap-6.mb-8');
                const actionButtons = document.querySelector('.flex.flex-col.sm\\:flex-row.items-center');
                // Almacena los valores de visualizaci√≥n originales si existen
                if(controlsPanel) controlsPanel.originalDisplay = controlsPanel.style.display;
                if(actionButtons) actionButtons.originalDisplay = actionButtons.style.display;

                if(controlsPanel) controlsPanel.style.display = 'none';
                if(actionButtons) actionButtons.style.display = 'none';
                
                renderProblems(state.problems, showAnswers); // Renderiza los problemas con/sin respuestas
            };

            const restoreWorksheetFromPDF = () => {
                // Restaura los estilos originales de la hoja de trabajo
                worksheet.style.cssText = worksheet.originalStyle || '';
                worksheet.style.width = '';
                worksheet.style.height = '';
                worksheet.style.maxWidth = '';
                worksheet.style.padding = '';
                worksheet.style.boxSizing = '';
                worksheet.style.aspectRatio = '';
                worksheet.style.overflow = '';

                // Restaura los controles y botones de acci√≥n
                const controlsPanel = document.querySelector('.grid-cols-1.lg\\:grid-cols-3.gap-6.mb-8');
                const actionButtons = document.querySelector('.flex.flex-col.sm\\:flex-row.items-center');
                if(controlsPanel) controlsPanel.style.display = controlsPanel.originalDisplay || '';
                if(actionButtons) actionButtons.style.display = actionButtons.originalDisplay || '';
                
                renderProblems(state.problems, false); // Vuelve a renderizar los problemas para la pantalla sin respuestas
            };

            // ========== EXPORTACI√ìN PDF ROBUSTA CON ENCABEZADO PERSONALIZADO ==========

            async function generarPDF(previsualizar = false, showAnswers = false) {
                try {
                    if (typeof showLoading === "function") showLoading("Generando PDF...");

                    // Oculta el modal de alerta si est√° visible
                    if (document.getElementById('alert-modal')) document.getElementById('alert-modal').classList.remove('visible');
                    
                    // Prepara la hoja de trabajo para la exportaci√≥n a PDF (establece dimensiones, oculta controles, renderiza problemas con/sin respuestas)
                    await prepareWorksheetForPDF(showAnswers); // Espera esta llamada
                    await new Promise(r => setTimeout(r, 100)); // Peque√±o retraso para asegurar las actualizaciones del DOM

                    const worksheet = document.getElementById('worksheet');
                    if (!worksheet) {
                        if (typeof showAlert === "function") showAlert('No se encontr√≥ la hoja para exportar.');
                        return;
                    }

                    // Obtiene el t√≠tulo actual de la hoja de trabajo
                    const currentWorksheetTitle = worksheetTitleElement.textContent.replace(/ /g, '_').toLowerCase(); // Reemplaza espacios con guiones bajos para el nombre del archivo

                    // Construye el nombre del archivo
                    const fecha = new Date().toISOString().slice(0, 10);
                    const finalFileName = `${currentWorksheetTitle}${showAnswers ? '_con_respuestas' : ''}_${fecha}.pdf`;
                    
                    const canvas = await html2canvas(worksheet, {
                        scale: 3, // Escala alta para mejor calidad
                        useCORS: true,
                        backgroundColor: '#fff'
                    });
                    
                    const { jsPDF } = window.jspdf; // Instanciaci√≥n correcta
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm', 
                        format: 'a4'
                    });
                    
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const pdfMargin = 10; // mm

                    let imgWidthInPdf = pdfWidth - (2 * pdfMargin); // Ancho de la imagen en PDF, respetando los m√°rgenes
                    let imgHeightInPdf = (canvas.height * imgWidthInPdf) / canvas.width; // Altura total escalada de todo el contenido del canvas

                    let currentCanvasY = 0; // Posici√≥n Y actual en el canvas original
                    let currentPageY = pdfMargin; // Posici√≥n Y actual en la p√°gina PDF actual

                    // Si el contenido es m√°s grande que una p√°gina, lo divide
                    if (imgHeightInPdf > pdfHeight - (2 * pdfMargin)) {
                        while (currentCanvasY < canvas.height) {
                            if (currentCanvasY > 0) { // A√±ade una nueva p√°gina para los segmentos siguientes
                                pdf.addPage();
                                currentPageY = pdfMargin; // Reinicia la Y para la nueva p√°gina
                            }

                            // Calcula la altura del contenido del canvas que cabe en una p√°gina PDF
                            const canvasSegmentHeightPx = (pdfHeight - (2 * pdfMargin)) * (canvas.width / imgWidthInPdf);

                            // Determina la altura real del segmento a cortar del canvas original para esta p√°gina
                            const clipHeightPx = Math.min(canvas.height - currentCanvasY, canvasSegmentHeightPx);

                            // Crea un canvas temporal para este segmento
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = clipHeightPx;
                            const tempCtx = tempCanvas.getContext('2d');
                            // Dibuja el segmento actual del canvas original en el canvas temporal
                            tempCtx.drawImage(canvas, 0, currentCanvasY, canvas.width, clipHeightPx, 0, 0, canvas.width, clipHeightPx);

                            const tempImgData = tempCanvas.toDataURL('image/png');
                            
                            // Calcula la altura de este segmento cuando se escala a las dimensiones del PDF
                            const segmentHeightInPdf = (clipHeightPx * imgWidthInPdf) / canvas.width;

                            // A√±ade la imagen del segmento al PDF
                            pdf.addImage(tempImgData, 'PNG', pdfMargin, currentPageY, imgWidthInPdf, segmentHeightInPdf);

                            currentCanvasY += clipHeightPx; // Pasa al siguiente segmento en el canvas original
                        }
                    } else {
                        // Si cabe en una sola p√°gina, lo centra verticalmente
                        const xOffset = (pdfWidth - imgWidthInPdf) / 2;
                        const yOffset = (pdfHeight - imgHeightInPdf) / 2;
                        pdf.addImage(canvas.toDataURL('image/png'), "PNG", xOffset, yOffset, imgWidthInPdf, imgHeightInPdf);
                    }
                    
                    if (previsualizar) {
                        window.open(pdf.output('bloburl'), '_blank');
                    } else {
                        pdf.save(finalFileName); // Usa el nombre de archivo generado din√°micamente
                    }
                } catch (err) {
                    if (typeof showAlert === "function") showAlert('Error al generar el PDF: ' + err.message);
                    console.error('Error al generar el PDF:', err);
                } finally {
                    if (typeof hideLoading === "function") hideLoading();
                    restoreWorksheetFromPDF(); // Siempre restaura la vista original
                }
            }

            async function exportarEjerciciosPDF() {
                if (state.problems.length === 0) {
                    showAlert("Primero genera una hoja de trabajo para poder descargarla.");
                    return;
                }
                await generarPDF(false, false); // No es necesario pasar el nombre del archivo, se genera din√°micamente
            }

            async function exportarRespuestasPDF() {
                if (state.problems.length === 0) {
                    showAlert("Primero genera una hoja de trabajo para poder descargarla con respuestas.");
                    return;
                }
                await generarPDF(false, true); // No es necesario pasar el nombre del archivo, se genera din√°micamente
            }

            // Event listeners para los botones de descarga
            const btnEjercicios = document.getElementById('download-btn');
            const btnRespuestas = document.getElementById('download-answers-btn');
            if (btnEjercicios) btnEjercicios.addEventListener('click', exportarEjerciciosPDF);
            if (btnRespuestas) btnRespuestas.addEventListener('click', exportarRespuestasPDF);

            // --- Inicializaci√≥n ---
            renderTableButtons();
            renderSeriesPatternButtons();
            renderSeriesDirectionButtons();
            updateSeriesStartRangeSlider();
            renderPyramidSizeButtons();
            updateOperationControls();
            updateDigitControls();
            updateTablaNumericaControls();
            generateProblems(); 
        });
    </script>
</body>
</html>
