<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Hojas de Matemáticas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* Estilos para el modal de alerta personalizado */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-backdrop.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 90%;
            width: 400px;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .modal-backdrop.visible .modal-content {
            transform: scale(1);
        }
        /* Clase para ocultar visualmente el checkmark si es necesario */
        .check-icon {
            display: inline-block;
            margin-left: 0.5rem;
        }
        .control-button.selected .check-icon {
            display: inline-block;
        }
        .control-button:not(.selected) .check-icon {
            display: none;
        }
        /* Estilos específicos para las series */
        .series-problem {
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Alinea al inicio para que no se estire */
            flex-wrap: nowrap; /* !IMPORTANT: Prevents wrapping to next line */
            gap: 0.2rem; /* Espacio entre los elementos de la serie, ligeramente reducido */
            font-family: 'Inter', sans-serif; /* Fuente consistente */
            font-size: 1.1rem; /* Ajuste para que quepa bien */
            padding: 0.4rem 0;
            overflow-x: auto; /* Permite desplazamiento si la serie es demasiado larga (como fallback) */
        }
        .series-number-box {
            border: 2px solid #333; /* Más grueso y más oscuro */
            padding: 0.25rem 0.4rem 0.25rem 0.4rem; /* Adjusted padding: top, right, bottom, left */
            border-radius: 0.4rem;
            min-width: 3rem; /* Reduced min-width */
            height: 2.2rem; /* Reduced height slightly */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.05);
            background-color: #e0e0e0; /* Un gris claro sutil */
            color: #1a1a1a; /* Texto más oscuro dentro de la caja */
            box-sizing: border-box; /* Added for consistent sizing */
            line-height: 1; /* Ensure text sits well */
            font-size: 1rem; /* Slightly reduced font size */
        }
        .series-arrow {
            font-weight: bold;
            color: #333; /* Más oscuro */
            font-size: 1.1rem; /* Ligeramente más grande */
        }
        .series-pattern-op {
            color: #1a1a1a; /* Casi negro */
            font-weight: bolder; /* Más negrita */
            font-size: 0.95rem; /* Un poco más pequeño */
            min-width: 1.6rem; /* Reduced min-width */
            text-align: center;
        }
        /* Ajuste para el grid de problemas para que las series ocupen todo el ancho si es necesario */
        .problems-container-series {
            display: flex; /* Usamos flex para que cada serie ocupe todo el ancho */
            flex-direction: column;
            gap: 1.2rem; /* Espacio entre cada serie, ajustado para 12 series */
            /* Quitar las propiedades de grid para que las series se expandan horizontalmente */
            grid-template-columns: none !important;
        }
        .problems-container-normal {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 1.5rem; /* Espacio entre problemas normales */
        }

        /* Nuevos estilos para problemas normales (sumas, restas, multiplicaciones) */
        .problem-math-wrapper {
            display: flex;
            flex-direction: column;
            align-items: flex-end; /* Alinea todo el bloque a la derecha */
            font-size: 1.8rem; /* Tamaño de fuente base reducido */
            line-height: 1.1; /* Línea de altura reducida */
            width: fit-content; /* Se ajusta al contenido */
            margin-left: auto; /* Centra el problema en su celda */
            margin-right: auto;
            padding-bottom: 0.4rem; /* Espacio al final reducido */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Fuente monoespaciada para alineación de dígitos */
        }

        .problem-line {
            display: flex;
            justify-content: flex-end; /* Alinea los números a la derecha */
            width: 100%; /* Ocupa el ancho del wrapper */
        }

        .number-operand-top {
            text-align: right;
            min-width: 5ch; /* Reducido para ajustarse a menos dígitos */
        }

        .problem-line-bottom {
            margin-top: -0.1rem; /* Margen superior reducido */
            padding-bottom: 0.8rem; /* AUMENTADO: Padding inferior para separar la línea */
            border-bottom: 2px solid #333;
            position: relative;
            width: 100%;
            display: flex;
            align-items: baseline; /* Alinea el operador y el número base */
            justify-content: flex-end;
        }

        .operator-operand {
            flex-shrink: 0;
            text-align: left;
            width: 1.3rem; /* Ancho reducido */
            padding-right: 0.1rem;
            font-size: 1.3rem; /* Tamaño de fuente reducido */
            color: #1a1a1a;
            transform: translateY(0.2rem); /* Ajuste vertical para alinear con el número */
        }

        .number-operand-bottom {
            text-align: right;
            flex-grow: 1; /* Permite que el número ocupe el resto del espacio */
            min-width: 4ch; /* Reducido para ajustarse a menos dígitos */
        }

        .result-line-display {
            text-align: right;
            font-weight: bold;
            color: #1a1a1a;
            margin-top: 0.4rem; /* Espacio entre la línea de resultado y el número reducido */
            width: 100%;
        }

        .empty-result-space {
            display: block; /* Para que ocupe espacio y mantenga la estructura */
            height: 1.3rem; /* Altura para el espacio vacío del resultado reducido */
            width: 100%;
        }

        /* Estilos específicos para las pirámides */
        .pyramid-problem {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centra cada capa horizontalmente */
            gap: 0.4rem; /* Espacio entre capas reducido */
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* Fuente monoespaciada */
            font-size: 1.3rem; /* Tamaño de fuente para números de pirámide reducido */
            padding: 0.8rem 0; /* Padding reducido */
            margin-bottom: 0.8rem; /* Margen inferior reducido */
            border: 1px solid #ddd;
            border-radius: 0.6rem; /* Radio de borde reducido */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.05); /* Sombra reducida */
            background-color: #f9f9f9;
        }

        .pyramid-layer {
            display: flex;
            justify-content: center; /* Centra los números dentro de la capa */
            gap: 0.4rem; /* Espacio entre los números en la misma capa reducido */
            width: 100%;
        }

        .pyramid-number-box {
            border: 2px solid #333; /* Estilo similar a las series */
            padding: 0.3rem 0.5rem 0.1rem 0.5rem; /* Adjusted padding: top, right, bottom, left */
            border-radius: 0.3rem; /* Radio de borde reducido */
            min-width: 4.0rem; /* Reducido */
            height: 2.5rem; /* Reducido */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 500;
            background-color: #e0e0e0;
            color: #1a1a1a;
            box-sizing: border-box; /* Added for consistent sizing */
            line-height: 1; /* Ensure text sits well */
            font-size: 1.3rem; /* Reducido */
        }

        .pyramid-number-box.empty {
            background-color: #ffffff; /* Fondo blanco para las casillas vacías */
        }

        /* Estilos para el indicador de carga */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Mayor que el modal de alerta */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .loading-content {
            background-color: white;
            padding: 2rem 3rem;
            border-radius: 1.5rem;
            box-shadow: 0 15px 35px rgba(0,0,0,0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .loading-overlay.visible .loading-content {
            transform: scale(1);
        }
        .loading-icon {
            font-size: 4rem; /* Tamaño del icono */
            animation: spin 2s linear infinite; /* Animación de giro */
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- NUEVOS ESTILOS PARA VISTA PREVIA Y TABLAS --- */
        #preview-container {
            max-width: 840px; /* Ancho máximo para la vista previa */
            margin-left: auto;
            margin-right: auto;
            padding: 2rem;
            background-color: #f0f4f8;
            border-radius: 0.5rem;
        }

        #worksheet {
            /* Estilos para la vista previa en el navegador */
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            aspect-ratio: 210 / 297; /* Proporción A4 para la vista previa */
            width: 100%; /* Ocupa el 100% del contenedor de vista previa */
            overflow: hidden; /* Oculta el contenido que se desborda */
            padding: 5%; /* Padding relativo para la vista previa */
            display: flex;
            flex-direction: column;
        }

        #problems-container {
            flex-grow: 1; /* Permite que el contenedor de problemas crezca para llenar el espacio */
        }

        /* Estilos para las tablas numéricas y pitagóricas */
        .number-grid-container, .pitagorica-grid-wrapper {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            padding: 0.8rem; /* Padding interno para las tablas reducido */
            display: flex;
            flex-direction: column;
        }

        .number-grid-row {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 columnas de igual ancho */
            gap: 0.1rem; /* Gap reducido */
            flex: 1; /* Permite que las filas crezcan para llenar el espacio */
        }
        
        /* Modificado: Nueva clase para la cuadrícula completa de la tabla pitagórica */
        .pitagorica-full-grid {
            display: grid;
            grid-template-columns: repeat(11, 1fr); /* 11 columnas, todas iguales */
            grid-template-rows: repeat(11, 1fr);    /* 11 filas, todas iguales */
            gap: 0.1rem;
            width: 100%;
            height: 100%;
        }

        .pitagorica-header-cell {
            background-color: #e0e0e0; /* Fondo gris para los encabezados */
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #666; /* Borde más fino */
            border-radius: 0.15rem; /* Radio de borde reducido */
            box-sizing: border-box;
            aspect-ratio: 1 / 1; /* Mantiene las celdas cuadradas */
            font-size: 1.2vw; /* Escala con el ancho del viewport para la vista previa */
            min-width: 18px; /* Evita que las celdas sean demasiado pequeñas */
            min-height: 18px; /* Evita que las celdas sean demasiado pequeñas */
        }

        .pitagorica-header-cell.empty-corner {
            border: none;
            background: transparent;
            font-size: 1.6vw; /* Escala la 'X' con el viewport */
            font-weight: 900;
        }

        .number-grid-cell { /* Re-usado para las celdas de datos de la tabla pitagórica */
            width: auto; /* Ancho automático en el grid */
            height: auto; /* Altura automática en el grid */
            aspect-ratio: 1 / 1; /* Mantiene las celdas cuadradas */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid #666; /* Borde más fino */
            background-color: #fff;
            font-weight: 500;
            color: #333;
            border-radius: 0.15rem; /* Radio de borde reducido */
            box-sizing: border-box;
            font-size: 1.2vw; /* Escala con el ancho del viewport para la vista previa */
            min-width: 18px; /* Evita que las celdas sean demasiado pequeñas */
            min-height: 18px; /* Evita que las celdas sean demasiado pequeñas */
        }

        .number-grid-cell input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            background-color: transparent;
            font-size: inherit; /* Hereda el tamaño de fuente del padre */
            font-weight: 500;
            color: #333;
            -moz-appearance: textfield;
        }

        .number-grid-cell.prefilled {
            background-color: #e0e0e0;
            font-weight: bold;
            color: #1a1a1a;
        }
        
        /* Estilos actualizados para Diana Multiplicaciones (blanco y negro con líneas divisorias) */
        .diana-multiplicaciones-problem {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 200px;
            height: 200px;
            margin: auto;
            background-color: white;
        }

        .diana-center {
            width: 50px;
            height: 50px;
            background-color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: bold;
            color: black;
            border: 2px solid black;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }

        .diana-ring {
            position: absolute;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .diana-ring.inner {
            width: 110px;
            height: 110px;
            border: 2px solid black;
            background-color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .diana-ring.outer {
            width: 180px;
            height: 180px;
            border: 2px solid black;
            background-color: white;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        .diana-ring-item {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 20px;
            height: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            color: black;
        }

        .diana-answer-box input {
            width: 100%;
            height: 100%;
            text-align: center;
            border: 1px solid black;
            border-radius: 0.2rem;
            background-color: white;
            font-size: 0.8rem;
            font-weight: bold;
            color: black;
            -moz-appearance: textfield;
        }

        .diana-answer-box input::-webkit-outer-spin-button,
        .diana-answer-box input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .series-problem {
                font-size: 0.9rem;
            }
            .series-number-box {
                min-width: 2.2rem;
                padding: 0.2rem 0.5rem;
                height: 2.0rem;
                font-size: 0.9rem;
            }
            .series-pattern-op {
                font-size: 0.9rem;
                min-width: 1.8rem;
            }
            .problem-math-wrapper {
                font-size: 1.5rem; /* Ajuste de tamaño de fuente para móviles */
            }

            /* Responsive para pirámides */
            #problems-container[style*="grid-template-columns: repeat(4"] {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
            #problems-container[style*="grid-template-columns: repeat(3"] { /* For 4-2-1 base */
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
            #problems-container[style*="grid-template-columns: repeat(2"] { /* For 8-4-2-1 base */
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
             }
            
            /* Responsive para Diana Multiplicaciones */
            .diana-multiplicaciones-problem {
                width: 180px; /* Ajuste para pantallas más pequeñas */
                height: 180px;
            }
            .diana-center {
                width: 40px; /* Ajuste para pantallas más pequeñas */
                height: 40px;
                font-size: 1.2rem;
            }
            .diana-ring.inner {
                width: 90px; /* Ajuste para pantallas más pequeñas */
                height: 90px;
            }
            .diana-ring.outer {
                width: 150px; /* Ajuste para pantallas más pequeñas */
                height: 150px;
            }
            .diana-ring-item {
                width: 18px; /* Ajuste para pantallas más pequeñas */
                height: 18px;
                font-size: 0.7rem;
            }
            .diana-answer-box input {
                font-size: 0.7rem;
            }

            /* Adjust font size for tables on smaller screens */
            .number-grid-cell, .pitagorica-header-cell {
                font-size: 2.2vw; /* Adjust for mobile preview */
            }
            .pitagorica-header-cell.empty-corner {
                font-size: 2.5vw;
            }
        }
        
        @media (min-width: 840px) {
            /* Fixed font size for tables on larger screens for better PDF consistency */
            .number-grid-cell, .pitagorica-header-cell {
                font-size: 1.0rem; /* Ajustado para pantallas grandes */
            }
             .pitagorica-header-cell.empty-corner {
                font-size: 1.3rem; /* Ajustado para pantallas grandes */
            }
        }

        @media (max-width: 500px) { /* Even smaller screens, specifically for 4-2-1 and 2-1 bases */
             #problems-container[style*="grid-template-columns: repeat(2, minmax(0, 1fr))"] {
                 grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
             }
        }

        /* Nuevos estilos para el encabezado de la hoja de trabajo */
        .ascii-logo {
            line-height: 1;
            letter-spacing: 2px;
            color: #333;
            /* Se eliminó text-align: center; porque el contenedor flex lo manejará */
            /* Se eliminaron los márgenes verticales ya que se controlan por el contenedor flex */
        }
        .ascii-logo pre {
            font-size: 1.0rem; /* Tamaño del logo ASCII reducido */
        }
        .worksheet-title {
            text-align: left; /* Alineado a la izquierda dentro del contenedor flex */
            font-size: 1.4rem; /* Tamaño del título reducido */
            font-weight: 800;
            letter-spacing: 1px;
            color: #23395d;
            margin: 0; /* Elimina márgenes para que el contenedor flex controle el espaciado */
        }
        .worksheet-name-container {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            font-size: 1.1rem; /* Tamaño de la fuente del nombre reducido */
            margin-bottom: 2.5rem; /* Margen inferior ajustado para dejar más espacio */
            margin-top: 0rem; /* Margen superior ajustado a 0 para reducir el espacio */
            justify-content: flex-start;
        }
        .worksheet-name-label {
            font-weight: 600;
            color: #1a237e;
        }
        .worksheet-name-line {
            border-bottom: 1px dotted #333; /* Borde más fino */
            flex-grow: 1;
            height: 1.2em; /* Altura ajustada */
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="max-w-7xl mx-auto p-4 sm:p-8">
        <header class="relative flex items-center justify-center mb-8">
            <div class="text-center">
                <h1 class="text-4xl md:text-5xl font-bold text-gray-800">Generador de Hojas de Matemáticas</h1>
                <p class="text-lg text-gray-600 mt-2">Crea y descarga hojas de ejercicios personalizadas.</p>
            </div>
            <!-- ASCII Logo para la parte superior derecha de la página web principal -->
            <div class="absolute right-4 top-4" aria-hidden="true">
                <pre style="margin:0; font-family: 'Courier New', Courier, monospace; font-size: 0.8rem; line-height: 1; color:#333;">
╔═╦═╦═
╠═╬═╬═
╚═╝</pre>
            </div>
        </header>

        <!-- Panel de Controles -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8 p-6 bg-white rounded-2xl shadow-lg">
            <!-- Columna 1: Tipo de Operación -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">1. Tipo de Operación</h3>
                <div id="operation-buttons" class="space-y-2">
                    <button data-value="suma-simple" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Suma Simple</button>
                    <button data-value="suma-llevada" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-blue-600 text-white shadow-md">Suma con Llevada<span class="check-icon">&#10003;</span></button>
                    <button data-value="resta-simple" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Resta Simple</button>
                    <button data-value="resta-llevada" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Resta con Llevada</button>
                    <button data-value="multiplicacion" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Multiplicación</button>
                    <button data-value="series" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Series</button>
                    <button data-value="pyramid" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Pirámides Matemáticas</button>
                    <button data-value="tabla-numerica" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Tabla Numérica</button>
                    <button data-value="diana-multiplicaciones" class="control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300">Diana Multiplicaciones</button>
                </div>
            </div>

            <!-- Columna 2: Número de Dígitos y Cantidad de Problemas -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">2. Número de Dígitos</h3>
                <div id="digit-buttons" class="flex space-x-2 mb-6">
                   <button data-value="1" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">1 dígito</button>
                   <button data-value="2" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">2 dígitos</button>
                   <button data-value="3" class="digit-button flex-1 p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">3 dígitos</button>
                </div>

                <h3 class="font-bold text-lg mb-3 text-gray-700">3. Cantidad de Problemas</h3>
                <div id="num-problems-buttons" class="grid grid-cols-2 gap-2">
                    <button data-value="20" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">20 Problemas</button>
                    <button data-value="30" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">30 Problemas</button>
                    <button data-value="40" class="num-problems-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">40 Problemas</button>
                    </div>
            </div>

            <!-- Columna 3: Tablas de Multiplicar, Tipo y Patrón de Serie, Tamaño de Pirámide, Tabla Numérica -->
            <div class="lg:col-span-1">
                <h3 class="font-bold text-lg mb-3 text-gray-700">4. Tablas de Multiplicar</h3>
                <div id="multiplication-tables" class="grid grid-cols-5 gap-2 transition-opacity duration-300 opacity-30 mb-6">
                    </div>

                <!-- Sección: Tipo y Patrón de la Serie -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">5. Tipo y patrón de la serie</h3>
                <div id="series-controls-wrapper" class="transition-opacity duration-300 opacity-30">
                    <!-- Checkbox para Patrón y Dirección Aleatorios -->
                    <div class="mb-4 flex items-center">
                        <input type="checkbox" id="random-series-checkbox" class="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded mr-2">
                        <label for="random-series-checkbox" class="text-gray-700 text-sm font-medium">Patrón y Dirección Aleatorios</label>
                    </div>

                    <!-- Slider para Rango de Inicio para Series -->
                    <div id="series-start-range-slider-container" class="transition-opacity duration-300 opacity-30 mb-6">
                        <label for="series-start-range-slider" class="block text-sm font-medium text-gray-700 mb-2">Valores de inicio hasta: <span id="series-start-range-label" class="font-bold text-blue-600">99</span></label>
                        <input type="range" id="series-start-range-slider" min="0" max="9" step="1" value="9" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-lg">
                    </div>

                    <!-- Botones de dirección de series -->
                    <div id="series-direction-buttons" class="grid grid-cols-2 gap-2 mb-6">
                        </div>
                    <!-- Botones del patrón numérico -->
                    <div id="series-pattern-buttons" class="grid grid-cols-5 gap-2">
                        </div>
                </div>

                <!-- Nueva Sección: Tamaño de la Pirámide -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">6. Tamaño de la Pirámide</h3>
                <div id="pyramid-size-buttons" class="grid grid-cols-3 gap-2 transition-opacity duration-300 opacity-30">
                    <button data-value="2-1" class="pyramid-size-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">2-1</button>
                    <button data-value="4-2-1" class="pyramid-size-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">4-2-1</button>
                    </div>

                <!-- Nueva Sección: Opciones de Tabla Numérica -->
                <h3 class="font-bold text-lg mb-3 text-gray-700">7. Opciones de Tabla Numérica</h3>
                <div id="tabla-numerica-controls" class="grid grid-cols-1 gap-2 transition-opacity duration-300 opacity-30">
                    <button data-value="1-100" class="tabla-numerica-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-blue-600 text-white shadow-md">Números 1-100</button>
                    <button data-value="pitagorica" class="tabla-numerica-button p-3 rounded-lg transition-all duration-200 text-sm font-medium bg-gray-200 text-gray-800 hover:bg-gray-300">Tabla Pitagórica</button>
                </div>
            </div>
        </div>

        <!-- Botones de Acción -->
        <div class="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
            <button id="generate-btn" class="w-full sm:w-auto px-8 py-3 bg-green-600 text-white font-bold rounded-xl shadow-lg hover:bg-green-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Generar Nueva Hoja</button>
            <button id="download-btn" class="w-full sm:w-auto px-8 py-3 bg-red-600 text-white font-bold rounded-xl shadow-lg hover:bg-red-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Descargar PDF</button>
            <button id="download-answers-btn" class="w-full sm:w-auto px-8 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-lg hover:bg-indigo-700 transform hover:scale-105 transition-all duration-300 ease-in-out text-lg">Descargar Respuestas</button>
        </div>

        <!-- CONTENEDOR DE EXPORTACIÓN (AQUÍ SALE EL PDF) -->
        <div id="preview-container" class="mb-8">
            <div id="worksheet">
                <!-- Modificado: Alineación de elementos en el encabezado a 'items-start' -->
                <div class="flex items-start gap-4 mb-2"> 
                    <div class="ascii-logo" aria-hidden="true">
                        <pre style="margin:0; font-family: 'Courier New', Courier, monospace; font-size: 1.0rem; display:inline-block; text-align:left;">
╔═╦═╦═
╠═╬═╬═
╚═╝</pre>
                    </div>
                    <h2 class="worksheet-title">Hoja de Matemáticas</h2>
                </div>
                <div class="worksheet-name-container">
                    <span class="worksheet-name-label">Nombre:</span>
                    <span class="worksheet-name-line"></span>
                </div>
                <div id="problems-container" class="grid grid-cols-5 gap-x-8 gap-y-12"></div>
            </div>
        </div>
        
        <footer class="text-center mt-8 text-gray-500 text-sm">
            <p>Diseñado por AFB para ayudar en el aprendizaje de las matemáticas.</p>
        </footer>
    </div>

    <!-- Modales/overlays igual que antes... -->
    <div id="alert-modal" class="modal-backdrop">
        <div class="modal-content">
            <p id="alert-message" class="mb-4 text-lg"></p>
            <button id="alert-close-btn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">Cerrar</button>
        </div>
    </div>

    <div id="loading-overlay" class="loading-overlay">
        <div class="loading-content">
            <span class="loading-icon">🕒</span>
            <p class="text-xl font-semibold text-gray-700">Generando PDF...</p>
            <p class="text-sm text-gray-500">Esto puede tardar unos segundos.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Estado de la aplicación
            let state = {
                operation: 'suma-llevada', // Operación predeterminada al cargar
                digits: '2', // Dígitos predeterminados
                numProblems: 30, // Cantidad de problemas predeterminada (cambiado de 50 a 30)
                tables: new Array(10).fill(true), // Tablas de multiplicar seleccionadas (1-10)
                seriesPatterns: [true, false, false, false, false, false, false, false, false, false], // Patrones de series (1-10), predefinido a +1
                seriesDirections: ['progresiva'], // Dirección de series ('progresiva', 'regresiva'), predefinido a progresiva
                randomSeriesMode: false, // Modo aleatorio para series (patrón y dirección por paso)
                seriesStartMaxDecade: 9, // Máxima década para el número de inicio de series (0-9, representando 0s-90s)
                pyramidSize: '2-1', // Nuevo: Tamaño de la pirámide
                tablaNumericaType: '1-100', // Nuevo: Tipo de tabla numérica ('1-100', 'pitagorica')
                problems: [] // Almacena los problemas generados, incluyendo sus respuestas
            };

            // Elementos del DOM
            const operationButtonsContainer = document.getElementById('operation-buttons');
            const digitButtonsContainer = document.getElementById('digit-buttons');
            const numProblemsButtonsContainer = document.getElementById('num-problems-buttons');
            const multiplicationTablesContainer = document.getElementById('multiplication-tables');
            const seriesControlsWrapper = document.getElementById('series-controls-wrapper');
            const randomSeriesCheckbox = document.getElementById('random-series-checkbox');
            const seriesPatternButtonsContainer = document.getElementById('series-pattern-buttons');
            const seriesDirectionButtonsContainer = document.getElementById('series-direction-buttons');
            const seriesStartRangeSliderContainer = document.getElementById('series-start-range-slider-container'); // Contenedor del slider
            const seriesStartRangeSlider = document.getElementById('series-start-range-slider'); // El slider en sí
            const seriesStartRangeLabel = document.getElementById('series-start-range-label'); // Etiqueta del slider
            const pyramidSizeButtonsContainer = document.getElementById('pyramid-size-buttons'); // Nuevo
            const tablaNumericaControls = document.getElementById('tabla-numerica-controls'); // Nuevo
            const generateBtn = document.getElementById('generate-btn');
            const downloadBtn = document.getElementById('download-btn');
            const downloadAnswersBtn = document.getElementById('download-answers-btn');
            const problemsContainer = document.getElementById('problems-container');
            const worksheet = document.getElementById('worksheet');
            const worksheetTitleElement = document.querySelector('.worksheet-title'); // Ahora es una clase
            const previewContainer = document.getElementById('preview-container'); // Nuevo

            // Elementos del Modal
            const alertModal = document.getElementById('alert-modal');
            const alertMessage = document.getElementById('alert-message');
            const alertCloseBtn = document.getElementById('alert-close-btn');

            // Elementos del Overlay de carga
            const loadingOverlay = document.getElementById('loading-overlay');

            const checkIconSvg = `<span class="check-icon">&#10003;</span>`;
            
            downloadBtn.disabled = false;
            downloadAnswersBtn.disabled = false;
            
            // --- Funciones de Lógica ---
            const getRandomNumberByDigits = (numDigits) => {
                if (numDigits === 1) return Math.floor(Math.random() * 9) + 1; // 1-9 for regular ops
                const min = Math.pow(10, numDigits - 1);
                const max = Math.pow(10, numDigits) - 1;
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };

            const getDigitsArray = (num) => String(num).split('').map(Number);
            
            const isSimpleSum = (n1, n2) => {
                const d1 = getDigitsArray(n1).reverse();
                const d2 = getDigitsArray(n2).reverse();
                const len = Math.max(d1.length, d2.length);
                for (let i = 0; i < len; i++) {
                    if (((d1[i] || 0) + (d2[i] || 0)) >= 10) return false;
                }
                return true;
            };

            const isCarrySum = (n1, n2) => !isSimpleSum(n1, n2);
            
            const isSimpleSub = (n1, n2) => {
                const d1 = getDigitsArray(n1).reverse();
                const d2 = getDigitsArray(n2).reverse();
                if (n1 < n2) return false;

                for (let i = 0; i < d2.length; i++) {
                    if (d1[i] < d2[i]) return false;
                }
                return true;
            };

            const isCarrySub = (n1, n2) => (n1 >= n2) && !isSimpleSub(n1, n2);

            const generatePyramidNumbers = (baseCount, maxOverallPyramidValue, maxBaseNumberValue = null) => {
                let pyramid = [];
                let baseNumbers = [];
                let valid = false; 
                let attemptsToFindValidPyramid = 0;
                const maxAttemptsToFindValidPyramid = 500; 

                while (!valid && attemptsToFindValidPyramid < maxAttemptsToFindValidPyramid) {
                    baseNumbers = []; 
                    let zeroCount = 0; 
                    let currentPyramidBaseIsValid = true; 

                    let attemptsPerBase = 0;
                    const maxAttemptsPerBase = 100;

                    for (let i = 0; i < baseCount; i++) {
                        let num;
                        let innerNumAttempts = 0;
                        const maxInnerNumAttempts = 50; 
                        const currentMaxValForGeneration = maxBaseNumberValue !== null ? maxBaseNumberValue : maxOverallPyramidValue;

                        do {
                            num = Math.floor(Math.random() * (currentMaxValForGeneration + 1));

                            const minValForDigits = (parseInt(state.digits) === 1) ? 0 : Math.pow(10, parseInt(state.digits) - 1);
                            
                            if ( (num === 0 && zeroCount >= 1) || 
                                 (num < minValForDigits && num !== 0 && parseInt(state.digits) !== 1) ||
                                 (num > currentMaxValForGeneration) )
                            {
                                innerNumAttempts++;
                                continue;
                            }
                            
                            if (num === 0) {
                                zeroCount++;
                            }
                            break; 
                        } while (innerNumAttempts < maxInnerNumAttempts);

                        if (innerNumAttempts >= maxInnerNumAttempts) {
                            currentPyramidBaseIsValid = false; 
                            break;
                        }
                        baseNumbers.push(num);
                    }

                    if (!currentPyramidBaseIsValid || zeroCount > 1) { 
                        attemptsToFindValidPyramid++;
                        continue; 
                    }

                    pyramid = [baseNumbers];
                    let currentLayer = baseNumbers;
                    let allLayersValid = true;

                    while (currentLayer.length > 1) {
                        let nextLayer = [];
                        for (let i = 0; i < currentLayer.length - 1; i++) {
                            let sum = currentLayer[i] + currentLayer[i+1];
                            if (sum > maxOverallPyramidValue || sum < 0) {
                                allLayersValid = false;
                                break;
                            }
                            nextLayer.push(sum);
                        }
                        if (!allLayersValid) break;
                        pyramid.push(nextLayer);
                        currentLayer = nextLayer;
                    }

                    if (allLayersValid) {
                        valid = true; 
                    } else {
                        attemptsToFindValidPyramid++; 
                    }
                }
                
                return valid ? pyramid : null; 
            };


            // --- Función para mostrar alertas personalizadas ---
            const showAlert = (message) => {
                alertMessage.textContent = message;
                alertModal.classList.add('visible');
            };

            // --- Función para ocultar la alerta ---
            const hideAlert = () => {
                alertModal.classList.remove('visible');
            };

            // --- Funciones para mostrar/ocultar el overlay de carga ---
            const showLoading = (message = "Generando PDF...", subMessage = "Esto puede tardar unos segundos.") => {
                loadingOverlay.querySelector('p:first-of-type').textContent = message;
                loadingOverlay.querySelector('p:last-of-type').textContent = subMessage;
                loadingOverlay.classList.add('visible');
            };

            const hideLoading = () => {
                // Solo oculta el overlay de carga, no el modal de alerta
                loadingOverlay.classList.remove('visible');
            };

            // Helper for generateSeries
            const getRandomElement = (arr) => arr[Math.floor(Math.random() * arr.length)];

            /**
             * Generates a numeric series based on state configuration.
             * @param {Object} seriesState - Configuration state relevant to series generation
             * @param {boolean} seriesState.randomSeriesMode - If true, choose pattern and direction randomly
             * @param {number[]} seriesState.seriesPatterns - Selected patterns (as numbers), e.g. [1, 2]
             * @param {string[]} seriesState.seriesDirections - Selected directions, e.g. ['progresiva','regresiva']
             * @param {string} seriesState.digits - '1' or '2'
             * @param {number} seriesState.seriesStartMaxDecade - Starting decade (0–9)
             * @param {number} [numSquares=6] - Number of elements in series
             * @param {number} [maxAttempts=1000] - Number of retry attempts for the whole series
             * @returns {{ series: number[], operations: {direction:string, value:number}[] }}
             */
            function generateSeries(seriesState, numSquares = 6, maxAttempts = 1000) {
                const patterns = seriesState.seriesPatterns.map((p, idx) => p ? (idx + 1) : null).filter(val => val !== null);
                const directions = seriesState.seriesDirections;
                const randomMode = seriesState.randomSeriesMode;

                const digits = parseInt(seriesState.digits, 10);
                const minValForDigits = (digits === 1 ? 0 : Math.pow(10, digits - 1));
                const maxValForDigits = Math.min(Math.pow(10, digits) - 1, 99); // Max value is 99 for 2 digits

                const decadeMin = seriesState.seriesStartMaxDecade * 10;
                const decadeMax = Math.min(decadeMin + 9, maxValForDigits);

                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const series = [];
                    const operations = [];

                    let start;
                    let startAttempts = 0;
                    const maxStartAttempts = 50;
                    do {
                        start = decadeMin + Math.floor(Math.random() * (decadeMax - decadeMin + 1));
                        startAttempts++;
                    } while ((start < minValForDigits || start > maxValForDigits) && startAttempts < maxStartAttempts);

                    if (startAttempts >= maxStartAttempts) {
                        continue;
                    }

                    let current = start;
                    series.push(current);

                    let valid = true;
                    for (let i = 1; i < numSquares; i++) {
                        let stepPatternCandidate, stepDirectionCandidate;
                        let foundValidStep = false;
                        const maxStepAttempts = 20; // Max attempts to find a valid next step for current 'current' number

                        for (let stepAttempt = 0; stepAttempt < maxStepAttempts; stepAttempt++) {
                            if (randomMode) {
                                stepPatternCandidate = Math.floor(Math.random() * 10) + 1;
                                stepDirectionCandidate = Math.random() < 0.5 ? 'progresiva' : 'regresiva';
                            } else {
                                if (patterns.length === 0) {
                                    stepPatternCandidate = 2; // Defaults to +2 if no patterns selected
                                } else {
                                    stepPatternCandidate = getRandomElement(patterns); // Use the already mapped and filtered patterns
                                }

                                if (directions.length === 1) {
                                    stepDirectionCandidate = directions[0];
                                } else {
                                    stepDirectionCandidate = Math.random() < 0.5 ? 'progresiva' : 'regresiva';
                                }
                            }

                            let nextCandidate = stepDirectionCandidate === 'progresiva' ? current + stepPatternCandidate : current - stepPatternCandidate;

                            if (nextCandidate >= minValForDigits && nextCandidate <= maxValForDigits) {
                                series.push(nextCandidate);
                                operations.push({ direction: stepDirectionCandidate, value: stepPatternCandidate });
                                current = nextCandidate;
                                foundValidStep = true;
                                break; 
                            }
                        }

                        if (!foundValidStep) {
                            valid = false; 
                            break; 
                        }
                    }

                    if (valid && series.length === numSquares) {
                        return { series, operations };
                    }
                }

                throw new Error('No se pudo generar una serie válida con los criterios seleccionados.');
            }


            // --- Generación de Problemas ---
            const generateProblems = () => {
                hideAlert(); // Ocultar cualquier alerta existente al iniciar la generación
                showLoading("Generando problemas..."); // Mostrar el indicador de carga

                const newProblems = [];
                let attempts = 0;
                const maxAttempts = 5000;
                
                let totalProblemsToGenerate;
                if (state.operation === 'series') {
                    totalProblemsToGenerate = 8; // Fixed to 8 series problems for one page
                } else if (state.operation === 'tabla-numerica') {
                    totalProblemsToGenerate = 1; // Tabla numérica siempre es 1
                } else if (state.operation === 'pyramid') {
                    if (state.pyramidSize === '2-1') {
                        totalProblemsToGenerate = 24;
                    } else if (state.pyramidSize === '4-2-1') {
                        totalProblemsToGenerate = 12; 
                    }
                } else if (state.operation === 'diana-multiplicaciones') { 
                    totalProblemsToGenerate = 6;
                }
                else {
                    totalProblemsToGenerate = state.numProblems;
                }

                let pyramidStructure = null; 

                while (newProblems.length < totalProblemsToGenerate && attempts < maxAttempts) { 
                    let problem = null;

                    switch (state.operation) {
                        case 'suma-simple':
                        case 'suma-llevada':
                        case 'resta-simple':
                        case 'resta-llevada':
                        case 'multiplicacion':
                            const num1 = getRandomNumberByDigits(parseInt(state.digits));
                            let num2 = getRandomNumberByDigits(parseInt(state.digits));
                            
                            if (state.operation === 'multiplicacion') {
                                const selectedTables = state.tables.map((t, i) => t ? i + 1 : null).filter(Boolean);
                                if (selectedTables.length === 0) {
                                    attempts++;
                                    continue;
                                }
                                num2 = selectedTables[Math.floor(Math.random() * selectedTables.length)];
                                problem = { num1, num2, operator: '×', answer: num1 * num2 };
                            } else {
                                let currentNum1, currentNum2;
                                let conditionMet = false;
                                let innerAttempts = 0;
                                const maxInnerAttempts = 100;

                                do {
                                    currentNum1 = getRandomNumberByDigits(parseInt(state.digits));
                                    currentNum2 = getRandomNumberByDigits(parseInt(state.digits));
                                    
                                    if (state.operation === 'suma-simple') conditionMet = isSimpleSum(currentNum1, currentNum2);
                                    else if (state.operation === 'suma-llevada') conditionMet = isCarrySum(currentNum1, currentNum2);
                                    else if (state.operation === 'resta-simple') conditionMet = isSimpleSub(currentNum1, currentNum2);
                                    else if (state.operation === 'resta-llevada') conditionMet = isCarrySub(currentNum1, currentNum2);
                                    innerAttempts++;
                                } while (!conditionMet && innerAttempts < maxInnerAttempts);

                                if (conditionMet) {
                                    if (state.operation.startsWith('resta')) {
                                        problem = { num1: Math.max(currentNum1, currentNum2), num2: Math.min(currentNum1, currentNum2), operator: '−', answer: Math.max(currentNum1, currentNum2) - Math.min(currentNum1, currentNum2) };
                                    } else {
                                        problem = { num1: currentNum1, num2: currentNum2, operator: '+', answer: currentNum1 + currentNum2 };
                                    }
                                }
                            }
                            break;

                        case 'series':
                            const numSquaresSeries = 6; // Number of elements in series
                            const maxAttemptsToGenerateSeries = 1000;

                            // Adjust state for series generation if needed (e.g., digits 3 not supported)
                            if (parseInt(state.digits) === 3) {
                                state.digits = '2';
                                updateDigitControls(); // Update UI if state changed
                            }
                            if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                                state.seriesStartMaxDecade = 1;
                                updateSeriesStartRangeSlider(); // Update UI if state changed
                            }

                            try {
                                const { series, operations } = generateSeries({
                                    randomSeriesMode: state.randomSeriesMode,
                                    seriesPatterns: state.seriesPatterns, // Pass the raw boolean array, mapping done in generateSeries
                                    seriesDirections: state.seriesDirections,
                                    digits: state.digits,
                                    seriesStartMaxDecade: state.seriesStartMaxDecade
                                }, numSquaresSeries, maxAttemptsToGenerateSeries);

                                problem = {
                                    type: 'series',
                                    series: series,
                                    stepOperations: operations.map(op => ({ operator: op.direction === 'progresiva' ? '+' : '−', value: op.value })),
                                    answer: series
                                };
                            } catch (error) {
                                console.warn("No se pudo generar la serie:", error.message);
                                // Si no se puede generar una serie, 'problem' permanece nulo, y el bucle exterior reintenta.
                                // Esto evita mostrar una alerta por cada intento fallido durante la generación.
                            }
                            break;
                        
                        case 'pyramid':
                            let maxOverallPyramidValue;
                            let maxBaseNumberValue = null; 

                            if (parseInt(state.digits) === 1) {
                                maxOverallPyramidValue = 72;
                                maxBaseNumberValue = 9;
                            } else if (parseInt(state.digits) === 2) {
                                maxOverallPyramidValue = 99; 
                                maxBaseNumberValue = 5; 
                            }
                            
                            let baseCountPyramid;
                            if (state.pyramidSize === '2-1') baseCountPyramid = 2;
                            else if (state.pyramidSize === '4-2-1') baseCountPyramid = 4;

                            pyramidStructure = generatePyramidNumbers(baseCountPyramid, maxOverallPyramidValue, maxBaseNumberValue);

                            if (pyramidStructure) {
                                problem = {
                                    type: 'pyramid',
                                    pyramid: pyramidStructure,
                                    answer: pyramidStructure[pyramidStructure.length - 1][0]
                                };
                            }
                            break;

                        case 'tabla-numerica':
                            if (state.tablaNumericaType === '1-100') {
                                const grid100 = Array.from({ length: 10 }, (_, r) => 
                                    Array.from({ length: 10 }, (_, c) => (r * 10) + c + 1)
                                );
                                const prefilledCells = [];
                                const usedRows = new Set();
                                const numPrefilled = 10; 

                                let attemptsToFill = 0;
                                const maxAttemptsToFill = 100;

                                while (prefilledCells.length < numPrefilled && attemptsToFill < maxAttemptsToFill) {
                                    let randomRow;
                                    let rowFound = false;
                                    let rowAttempt = 0;
                                    const maxRowAttempts = 20;

                                    do {
                                        randomRow = Math.floor(Math.random() * 10);
                                        if (!usedRows.has(randomRow)) {
                                            rowFound = true;
                                            usedRows.add(randomRow);
                                        }
                                        rowAttempt++;
                                    } while (!rowFound && rowAttempt < maxRowAttempts);

                                    if (!rowFound) {
                                        console.warn("No se pudo encontrar una fila única para las celdas pre-rellenadas.");
                                        break; 
                                    }

                                    const randomCol = Math.floor(Math.random() * 10); 
                                    const value = grid100[randomRow][randomCol];
                                    prefilledCells.push({ row: randomRow, col: randomCol, value: value });
                                    attemptsToFill++;
                                }
                                problem = {
                                    type: 'tabla-numerica',
                                    subType: '1-100',
                                    grid: grid100,
                                    prefilledCells: prefilledCells, 
                                    answer: grid100
                                };
                            } else if (state.tablaNumericaType === 'pitagorica') {
                                const gridPitagorica = Array.from({ length: 10 }, (_, r) => 
                                    Array.from({ length: 10 }, (_, c) => (r + 1) * (c + 1))
                                );
                                problem = {
                                    type: 'tabla-numerica',
                                    subType: 'pitagorica',
                                    grid: gridPitagorica,
                                    answer: gridPitagorica
                                };
                            }
                            break;
                        
                        case 'diana-multiplicaciones':
                            const selectedTables = state.tables.map((t, i) => t ? i + 1 : null).filter(Boolean);
                            if (selectedTables.length === 0) {
                                showAlert("Por favor, selecciona al menos una tabla de multiplicar para las Dianas.");
                                return;
                            }
                            const tableNumber = selectedTables[Math.floor(Math.random() * selectedTables.length)];
                            problem = { type: 'diana-multiplicaciones', tableNumber: tableNumber };
                            break;
                    }
                    
                    if (problem) {
                        newProblems.push(problem);
                    }
                    attempts++;
                }

                if (newProblems.length === 0 && attempts >= maxAttempts) {
                    let errorMessage = "No se pudieron generar problemas con los criterios seleccionados. Intenta con otros ajustes.";
                    if (state.operation === 'multiplicacion' && state.tables.filter(Boolean).length === 0) {
                        errorMessage = "Por favor, selecciona al menos una tabla de multiplicar.";
                    } else if (state.operation === 'series' && state.seriesPatterns.filter(Boolean).length === 0 && !state.randomSeriesMode) {
                        errorMessage = "Por favor, selecciona al menos un patrón de serie o activa el modo aleatorio.";
                    } else if (state.operation === 'series' && state.seriesDirections.filter(Boolean).length === 0 && !state.randomSeriesMode) {
                        errorMessage = "Por favor, selecciona al menos una dirección para las series (Progresiva o Regresiva) o activa el modo aleatorio.";
                    } else if (state.operation === 'pyramid' && !pyramidStructure) {
                         errorMessage = `No se pudieron generar pirámides del tamaño ${state.pyramidSize} con números de ${state.digits} dígitos.`;
                    }
                    showAlert(errorMessage);
                }
                state.problems = newProblems; 
                renderProblems(newProblems);
                hideLoading(); // Ocultar el indicador de carga al finalizar la generación o mostrar la alerta
            };
            
            // --- Renderizado ---
            const renderProblems = (problems, showAnswers = false) => {
                problemsContainer.innerHTML = '';
                
                problemsContainer.style.display = '';
                problemsContainer.style.flexDirection = '';
                problemsContainer.style.gap = '';
                problemsContainer.style.gridTemplateColumns = '';

                problemsContainer.classList.remove('problems-container-normal', 'problems-container-series');

                if (state.operation === 'series') {
                    problemsContainer.classList.add('problems-container-series'); 
                } else if (state.operation === 'pyramid') {
                    problemsContainer.style.display = 'grid';
                    problemsContainer.style.gap = '2.0rem'; /* Reducido */
                    if (state.pyramidSize === '4-2-1') { 
                        problemsContainer.style.gridTemplateColumns = 'repeat(3, minmax(0, 1fr))';
                    } else if (state.pyramidSize === '2-1') {
                        problemsContainer.style.gridTemplateColumns = 'repeat(4, minmax(0, 1fr))';
                    }
                } else if (state.operation === 'tabla-numerica') {
                    problemsContainer.style.display = 'flex';
                    problemsContainer.style.flexDirection = 'column';
                    problemsContainer.style.gap = '0.8rem'; /* Reducido */
                } else if (state.operation === 'diana-multiplicaciones') {
                    problemsContainer.style.display = 'grid';
                    problemsContainer.style.gridTemplateColumns = 'repeat(2, minmax(0, 1fr))';
                    problemsContainer.style.gap = '0.8rem'; /* Reducido */
                }
                else {
                    problemsContainer.classList.add('problems-container-normal'); 
                }

                if (problems.length === 0) {
                    problemsContainer.innerHTML = `<div class="col-span-full text-center py-16 text-gray-500">
                        <p>¡Genera una hoja de trabajo para empezar!</p>
                        <p class="text-sm mt-2">Usa los controles de arriba y haz clic en "Generar Nueva Hoja".</p>
                    </div>`;
                    return;
                }

                problems.forEach((p, index) => {
                    const problemEl = document.createElement('div');
                    if (p.type === 'series') {
                        problemEl.className = 'series-problem w-full'; 

                        const firstNumSpan = document.createElement('span');
                        firstNumSpan.className = 'series-number-box';
                        firstNumSpan.textContent = p.series[0];
                        problemEl.appendChild(firstNumSpan);

                        p.stepOperations.forEach((stepOp, i) => {
                            const arrowSpan1 = document.createElement('span');
                            arrowSpan1.className = 'series-arrow';
                            arrowSpan1.textContent = ' → '; 
                            problemEl.appendChild(arrowSpan1);

                            const patternOpSpan = document.createElement('span');
                            patternOpSpan.className = 'series-pattern-op';
                            patternOpSpan.textContent = `${stepOp.operator}${stepOp.value}`;
                            problemEl.appendChild(patternOpSpan);
                            
                            const arrowSpan2 = document.createElement('span');
                            arrowSpan2.className = 'series-arrow';
                            arrowSpan2.textContent = ' → '; 
                            problemEl.appendChild(arrowSpan2);

                            const nextNumSpan = document.createElement('span');
                            nextNumSpan.className = 'series-number-box';
                            if (showAnswers) {
                                nextNumSpan.textContent = p.series[i + 1];
                            } else {
                                nextNumSpan.textContent = ''; 
                            }
                            problemEl.appendChild(nextNumSpan);
                        });

                    } else if (p.type === 'pyramid') {
                        problemEl.className = 'pyramid-problem w-full';
                        const reversedPyramid = [...p.pyramid].reverse();

                        reversedPyramid.forEach((layer, layerIndex) => {
                            const layerDiv = document.createElement('div');
                            layerDiv.className = 'pyramid-layer';
                            
                            layer.forEach((num, numIndex) => {
                                const numSpan = document.createElement('span');
                                numSpan.className = 'pyramid-number-box';
                                
                                if (showAnswers || layerIndex === reversedPyramid.length - 1) {
                                    numSpan.textContent = num;
                                } else {
                                    numSpan.textContent = '';
                                    numSpan.classList.add('empty');
                                }
                                layerDiv.appendChild(numSpan);
                            });
                            problemEl.appendChild(layerDiv);
                        });

                    } else if (p.type === 'tabla-numerica') { 
                        problemEl.className = 'w-full h-full flex justify-center';

                        if (p.subType === '1-100') {
                            const gridContainer = document.createElement('div');
                            gridContainer.className = 'number-grid-container';
                            
                            p.grid.forEach((row, rowIndex) => {
                                const rowDiv = document.createElement('div');
                                rowDiv.className = 'number-grid-row';
                                row.forEach((cellValue, colIndex) => {
                                    const cellDiv = document.createElement('div');
                                    cellDiv.className = 'number-grid-cell';
                                    
                                    const prefilled = p.prefilledCells.some(c => c.row === rowIndex && c.col === colIndex);
                                    if (prefilled) {
                                        cellDiv.textContent = cellValue;
                                        cellDiv.classList.add('prefilled');
                                    } else {
                                        const input = document.createElement('input');
                                        input.type = 'number';
                                        input.min = '1';
                                        input.max = '100';
                                        input.readOnly = showAnswers;
                                        if (showAnswers) {
                                            input.value = cellValue;
                                        }
                                        cellDiv.appendChild(input);
                                    }
                                    rowDiv.appendChild(cellDiv);
                                });
                                gridContainer.appendChild(rowDiv);
                            });
                            problemEl.appendChild(gridContainer);

                        } else if (p.subType === 'pitagorica') {
                            const pitagoricaWrapper = document.createElement('div');
                            pitagoricaWrapper.className = 'pitagorica-grid-wrapper';

                            const fullGridDiv = document.createElement('div');
                            fullGridDiv.className = 'pitagorica-full-grid';

                            // Celda de la esquina (X)
                            const emptyCorner = document.createElement('div');
                            emptyCorner.className = 'pitagorica-header-cell empty-corner';
                            emptyCorner.textContent = '×';
                            fullGridDiv.appendChild(emptyCorner);

                            // Encabezados superiores (1-10)
                            for (let i = 1; i <= 10; i++) {
                                const headerCell = document.createElement('div');
                                headerCell.className = 'pitagorica-header-cell';
                                headerCell.textContent = i;
                                fullGridDiv.appendChild(headerCell);
                            }

                            // Encabezados laterales (1-10) y celdas de la cuadrícula principal
                            for (let r = 0; r < 10; r++) { // 10 filas para encabezados laterales y cuadrícula principal
                                // Celda de encabezado lateral
                                const sideHeaderCell = document.createElement('div');
                                sideHeaderCell.className = 'pitagorica-header-cell';
                                sideHeaderCell.textContent = r + 1;
                                fullGridDiv.appendChild(sideHeaderCell);

                                // Celdas de la cuadrícula principal (10 columnas por fila)
                                for (let c = 0; c < 10; c++) {
                                    const cellDiv = document.createElement('div');
                                    cellDiv.className = 'number-grid-cell';
                                    const input = document.createElement('input');
                                    input.type = 'number';
                                    input.readOnly = showAnswers;
                                    if (showAnswers) {
                                        input.value = p.grid[r][c];
                                    }
                                    cellDiv.appendChild(input);
                                    fullGridDiv.appendChild(cellDiv);
                                }
                            }
                            pitagoricaWrapper.appendChild(fullGridDiv);
                            problemEl.appendChild(pitagoricaWrapper);
                        }

                    } else if (p.type === 'diana-multiplicaciones') {
                        problemEl.className = 'diana-multiplicaciones-problem';

                        const centerDiv = document.createElement('div');
                        centerDiv.className = 'diana-center';
                        centerDiv.textContent = `${p.tableNumber}x`;
                        problemEl.appendChild(centerDiv);

                        const innerRingDiv = document.createElement('div');
                        innerRingDiv.className = 'diana-ring inner';
                        problemEl.appendChild(innerRingDiv);

                        const outerRingDiv = document.createElement('div');
                        outerRingDiv.className = 'diana-ring outer';
                        // Aplica el fondo conic-gradient directamente al anillo exterior para las líneas
                        outerRingDiv.style.background = `conic-gradient(transparent 0deg 17deg, black 17deg 18deg, transparent 18deg 35deg, black 35deg 36deg, transparent 36deg 53deg, black 53deg 54deg, transparent 54deg 71deg, black 71deg 72deg, transparent 72deg 89deg, black 89deg 90deg, transparent 90deg 107deg, black 107deg 108deg, transparent 108deg 125deg, black 125deg 126deg, transparent 126deg 143deg, black 143deg 144deg, transparent 144deg 161deg, black 161deg 162deg, transparent 162deg 179deg, black 179deg 180deg, transparent 180deg 197deg, black 197deg 198deg, transparent 198deg 215deg, black 215deg 216deg, transparent 216deg 233deg, black 233deg 234deg, transparent 234deg 251deg, black 251deg 252deg, transparent 252deg 269deg, black 269deg 270deg, transparent 270deg 287deg, black 287deg 288deg, transparent 288deg 305deg, black 305deg 306deg, transparent 306deg 323deg, black 323deg 324deg, transparent 324deg 341deg, black 341deg 342deg, transparent 342deg 359deg, black 359deg 360deg)`;
                        outerRingDiv.style.opacity = '0.5'; // Aplica opacidad directamente
                        outerRingDiv.style.zIndex = '0'; // Asegúrate de que esté detrás de otros elementos
                        problemEl.appendChild(outerRingDiv);

                        const numItems = 10;
                        // Actualiza innerRadius y outerRadius para que coincidan con los nuevos tamaños de los anillos
                        const innerRadius = 110 / 2; // 110px de ancho -> 55px de radio
                        const outerRadius = 180 / 2; // 180px de ancho -> 90px de radio
                        const angleStep = (2 * Math.PI) / numItems; 

                        for (let i = 0; i < numItems; i++) {
                            const currentAngle = (-Math.PI / 2) + (i * angleStep); 

                            const numDiv = document.createElement('div');
                            numDiv.className = `diana-ring-item diana-number`;
                            numDiv.textContent = i + 1;

                            const numX = innerRadius + innerRadius * Math.cos(currentAngle);
                            const numY = innerRadius + innerRadius * Math.sin(currentAngle); 

                            numDiv.style.left = `${numX}px`;
                            numDiv.style.top = `${numY}px`;
                            numDiv.style.transform = 'translate(-50%, -50%)';
                            innerRingDiv.appendChild(numDiv);

                            const answerBoxDiv = document.createElement('div');
                            answerBoxDiv.className = `diana-ring-item diana-answer-box`;
                            const answerInput = document.createElement('input');
                            answerInput.type = 'number';
                            answerInput.readOnly = showAnswers;
                            if (showAnswers) {
                                answerInput.value = (i + 1) * p.tableNumber;
                            }
                            answerBoxDiv.appendChild(answerInput);

                            const ansX = outerRadius + outerRadius * Math.cos(currentAngle);
                            const ansY = outerRadius + outerRadius * Math.sin(currentAngle); 

                            answerBoxDiv.style.left = `${ansX}px`;
                            answerBoxDiv.style.top = `${ansY}px`;
                            answerBoxDiv.style.transform = 'translate(-50%, -50%)';
                            outerRingDiv.appendChild(answerBoxDiv);
                        }
                    } else {
                        problemEl.className = 'problem-math-wrapper';
                        problemEl.innerHTML = `
                            <div class="problem-line">
                                <span class="number-operand-top">${p.num1}</span>
                            </div>
                            <div class="problem-line problem-line-bottom">
                                <span class="operator-operand">${p.operator}</span>
                                <span class="number-operand-bottom">${p.num2}</span>
                            </div>
                            <div class="result-line-display">
                                ${showAnswers ? `<span class="result-number">${p.answer}</span>` : '<span class="empty-result-space"></span>'}
                            </div>
                        `;
                    }
                    problemsContainer.appendChild(problemEl);
                });
            };

            const updateOperationControls = () => {
                operationButtonsContainer.querySelectorAll('button').forEach(btn => {
                    const value = btn.dataset.value;
                    if (value === state.operation) {
                        btn.className = 'control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-blue-600 text-white shadow-md selected';
                        if (!btn.querySelector('.check-icon')) btn.insertAdjacentHTML('beforeend', checkIconSvg);
                    } else {
                           btn.className = 'control-button w-full text-left p-3 rounded-lg transition-all duration-200 text-sm font-medium flex items-center justify-between bg-gray-200 text-gray-800 hover:bg-gray-300';
                           const icon = btn.querySelector('.check-icon');
                           if (icon) icon.remove();
                    }
                });
                const isMultiplication = state.operation === 'multiplicacion';
                const isSeries = state.operation === 'series'; 
                const isPyramid = state.operation === 'pyramid';
                const isTablaNumerica = state.operation === 'tabla-numerica';
                const isDianaMultiplicaciones = state.operation === 'diana-multiplicaciones';

                multiplicationTablesContainer.classList.toggle('opacity-30', !(isMultiplication || isDianaMultiplicaciones));
                multiplicationTablesContainer.querySelectorAll('button').forEach(btn => btn.disabled = !(isMultiplication || isDianaMultiplicaciones));

                seriesControlsWrapper.classList.toggle('opacity-30', !isSeries);
                randomSeriesCheckbox.disabled = !isSeries;
                const disableManualSeriesControls = !isSeries || state.randomSeriesMode;
                seriesPatternButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = disableManualSeriesControls);
                seriesDirectionButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = disableManualSeriesControls);
                seriesStartRangeSliderContainer.classList.toggle('opacity-30', !isSeries);
                seriesStartRangeSlider.disabled = !isSeries;
                seriesStartRangeLabel.classList.toggle('text-gray-400', !isSeries);

                pyramidSizeButtonsContainer.classList.toggle('opacity-30', !isPyramid);
                pyramidSizeButtonsContainer.querySelectorAll('button').forEach(btn => btn.disabled = !isPyramid);

                tablaNumericaControls.classList.toggle('opacity-30', !isTablaNumerica);
                tablaNumericaControls.querySelectorAll('button').forEach(btn => btn.disabled = !isTablaNumerica);

                numProblemsButtonsContainer.closest('div').style.display = (isSeries || isPyramid || isTablaNumerica || isDianaMultiplicaciones) ? 'none' : 'grid'; 
                digitButtonsContainer.closest('div').style.display = (isSeries || isPyramid || isTablaNumerica || isDianaMultiplicaciones) ? 'none' : 'flex';

                // --- Lógica de ajuste automático para series al cambiar la operación ---
                if (isSeries) {
                    if (parseInt(state.digits) === 3) {
                        state.digits = '2'; // Forzar a 2 dígitos si estaba en 3
                    }
                    if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                        state.seriesStartMaxDecade = 1;
                    }
                }
                // --- Fin de lógica de ajuste automático ---

                updateDigitControls(); // Asegurarse de que los controles de dígitos se actualicen
                updateTablaNumericaControls();
                updateSeriesStartRangeSlider(); // Asegurarse de que el slider de series se actualice
            };
            
            const updateDigitControls = () => {
                const isTablaNumericaOperation = state.operation === 'tabla-numerica'; 
                const isDianaMultiplicaciones = state.operation === 'diana-multiplicaciones';
                const isSeriesOperation = state.operation === 'series'; // Nuevo

                digitButtonsContainer.querySelectorAll('button').forEach(btn => {
                    const digitValue = parseInt(btn.dataset.value);
                    const isPyramidOperation = state.operation === 'pyramid';
                    let shouldBeDisabled = false;

                    if (isPyramidOperation) {
                        if (digitValue === 1 && state.pyramidSize === '4-2-1') {
                            shouldBeDisabled = true;
                        }
                        if (digitValue === 2) {
                            shouldBeDisabled = true;
                        }
                        if (digitValue === 3) {
                            shouldBeDisabled = true;
                        }
                    } else if (isTablaNumericaOperation || isDianaMultiplicaciones) {
                        shouldBeDisabled = true;
                    } else if (isSeriesOperation && digitValue === 3) { // Deshabilitar 3 dígitos para series
                        shouldBeDisabled = true;
                    }

                    if (shouldBeDisabled) {
                        btn.disabled = true;
                        btn.classList.remove('bg-blue-600', 'text-white', 'shadow-md', 'bg-gray-200', 'text-gray-800');
                        btn.classList.add('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                        // Si el dígito seleccionado actualmente se desactiva, cambiarlo a un valor válido
                        if (parseInt(state.digits) === digitValue) {
                            const availableDigits = Array.from(digitButtonsContainer.querySelectorAll('button'))
                                .filter(b => !b.disabled)
                                .map(b => parseInt(b.dataset.value));
                            if (availableDigits.length > 0) {
                                state.digits = String(availableDigits[0]);
                            } else {
                                state.digits = '1'; // Fallback si no hay dígitos disponibles (no debería pasar)
                            }
                        }
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('bg-gray-300', 'text-gray-500', 'cursor-not-allowed');
                        btn.classList.toggle('bg-blue-600', digitValue === parseInt(state.digits));
                        btn.classList.toggle('text-white', digitValue === parseInt(state.digits));
                        btn.classList.toggle('shadow-md', digitValue === parseInt(state.digits));
                        btn.classList.toggle('bg-gray-200', digitValue !== parseInt(state.digits));
                        btn.classList.toggle('text-gray-800', digitValue !== parseInt(state.digits));
                    }
                });
                digitButtonsContainer.closest('div').style.display = (isTablaNumericaOperation || isDianaMultiplicaciones) ? 'none' : 'flex';
                updateSeriesStartRangeSlider(); // Asegurarse de que el slider de series se actualice después de cambiar dígitos
            };

            const updateNumProblemsControls = () => {
                numProblemsButtonsContainer.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('bg-blue-600', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('text-white', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('shadow-md', parseInt(btn.dataset.value) === state.numProblems);
                    btn.classList.toggle('bg-gray-200', parseInt(btn.dataset.value) !== state.numProblems);
                    btn.classList.toggle('text-gray-800', btn.dataset.value !== state.problems);
                });
            };

            const renderTableButtons = () => {
                 multiplicationTablesContainer.innerHTML = '';
                 for (let i = 0; i < 10; i++) {
                    const tableBtn = document.createElement('button');
                    tableBtn.textContent = i + 1;
                    tableBtn.dataset.index = i;
                    tableBtn.className = `p-3 rounded-lg text-center transition-colors duration-200 font-medium ${state.tables[i] ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    tableBtn.disabled = !(state.operation === 'multiplicacion' || state.operation === 'diana-multiplicaciones');
                    multiplicationTablesContainer.appendChild(tableBtn);
                 }
            };
            
            const renderSeriesPatternButtons = () => {
                seriesPatternButtonsContainer.innerHTML = '';
                for (let i = 0; i < 10; i++) { 
                    const patternValue = i + 1; 
                    const patternBtn = document.createElement('button');
                    patternBtn.textContent = patternValue;
                    patternBtn.dataset.index = i; 
                    patternBtn.className = `p-3 rounded-lg text-center transition-colors duration-200 font-medium ${state.seriesPatterns[i] && !state.randomSeriesMode ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    patternBtn.disabled = state.operation !== 'series' || state.randomSeriesMode; 
                    seriesPatternButtonsContainer.appendChild(patternBtn);
                }
            };

            const renderSeriesDirectionButtons = () => {
                seriesDirectionButtonsContainer.innerHTML = '';
                const directions = ['progresiva', 'regresiva'];
                const labels = { 'progresiva': 'Progresiva (+)', 'regresiva': 'Regresiva (-)' };

                directions.forEach(direction => {
                    const directionBtn = document.createElement('button');
                    directionBtn.textContent = labels[direction];
                    directionBtn.dataset.value = direction;
                    const isSelected = state.seriesDirections.includes(direction);
                    directionBtn.className = `series-direction-button flex-1 p-3 rounded-lg text-center transition-colors duration-200 text-sm font-medium ${isSelected && !state.randomSeriesMode ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}`;
                    directionBtn.disabled = state.operation !== 'series' || state.randomSeriesMode; 
                    seriesDirectionButtonsContainer.appendChild(directionBtn);
                });
            };

            const updateSeriesStartRangeSlider = () => {
                const numStepsInSeries = 5; // 6 numbers in series means 5 steps/jumps

                // Always allow slider to go from 0 to 9 decades
                seriesStartRangeSlider.min = 0;
                seriesStartRangeSlider.max = 9;
                
                let suggestedDecade = state.seriesStartMaxDecade; // Start with current state value

                if (state.operation === 'series' && !state.randomSeriesMode) {
                    const activePatterns = state.seriesPatterns.map((p, idx) => p ? (idx + 1) : null).filter(val => val !== null);
                    const activeDirections = state.seriesDirections;

                    if (activePatterns.length === 0 || activeDirections.length === 0) {
                        // If no patterns or directions selected, revert to a default safe range
                        suggestedDecade = (parseInt(state.digits) === 2) ? 9 : 0;
                    } else {
                        let minPossibleDecade = 0; // The lowest decade the slider can go to
                        let maxPossibleDecade = 9; // The highest decade the slider can go to

                        // Logic for progressive series to prevent exceeding 99
                        if (activeDirections.includes('progresiva')) {
                            let highestMinDecadeForProgressive = 0; // We need to satisfy the most restrictive pattern
                            activePatterns.forEach(pattern => {
                                let requiredMinStartValue;
                                // Mapeo personalizado del usuario para series progresivas
                                if (pattern === 10) requiredMinStartValue = 30;
                                else if (pattern === 9) requiredMinStartValue = 40;
                                else if (pattern === 8) requiredMinStartValue = 40; // Corregido: antes era minMinStartValue
                                else if (pattern === 7) requiredMinStartValue = 50;
                                else if (pattern === 6) requiredMinStartValue = 50;
                                else if (pattern === 5) requiredMinStartValue = 60;
                                else if (pattern === 4) requiredMinStartValue = 70;
                                else if (pattern === 3) requiredMinStartValue = 70;
                                else if (pattern === 2) requiredMinStartValue = 70;
                                else if (pattern === 1) requiredMinStartValue = 0; // "cualquiera"

                                highestMinDecadeForProgressive = Math.max(highestMinDecadeForProgressive, Math.floor(requiredMinStartValue / 10));
                            });
                            minPossibleDecade = Math.max(minPossibleDecade, highestMinDecadeForProgressive);
                        }

                        // Logic for regressive series to prevent falling below 0
                        if (activeDirections.includes('regresiva')) {
                            let lowestMaxDecadeForRegressive = 9; // We need to satisfy the most restrictive pattern
                            activePatterns.forEach(pattern => {
                                // Calculate the minimum starting value required to not go below 0
                                // If start is X, then X - (pattern * numStepsInSeries) >= 0
                                // X >= pattern * numStepsInSeries
                                let minStartValueRequired = pattern * numStepsInSeries;
                                // The highest decade we can start from while ensuring minStartValueRequired is met
                                // This means the starting number needs to be at least minStartValueRequired
                                // So, the decade should be at least Math.ceil(minStartValueRequired / 10)
                                let minDecadeForRegressiveStart = Math.ceil(minStartValueRequired / 10);
                                if (minDecadeForRegressiveStart > 9) minDecadeForRegressiveStart = 9; // Cap at 90s if too high

                                lowestMaxDecadeForRegressive = Math.min(lowestMaxDecadeForRegressive, minDecadeForRegressiveStart);
                            });
                            maxPossibleDecade = Math.min(maxPossibleDecade, lowestMaxDecadeForRegressive);
                        }
                        
                        // If both progressive and regressive are selected, find a common ground
                        // This part is complex as the ranges can conflict.
                        // For simplicity, let's take the most restrictive range for the suggested decade.
                        if (activeDirections.includes('progresiva') && activeDirections.includes('regresiva')) {
                            // Si ambos están seleccionados, el rango podría ser muy pequeño o inexistente.
                            // Por ahora, priorizaremos el límite inferior del rango progresivo y el límite superior del rango regresivo.
                            suggestedDecade = Math.max(minPossibleDecade, Math.min(state.seriesStartMaxDecade, maxPossibleDecade));
                        } else if (activeDirections.includes('progresiva')) {
                            suggestedDecade = Math.max(state.seriesStartMaxDecade, minPossibleDecade); // Asegurarse de que sea al menos el mínimo requerido
                        } else if (activeDirections.includes('regresiva')) {
                            suggestedDecade = Math.min(state.seriesStartMaxDecade, maxPossibleDecade); // Asegurarse de que sea como máximo el máximo permitido
                        }

                        // Asegurarse de que suggestedDecade esté dentro del mínimo/máximo absoluto del slider
                        suggestedDecade = Math.max(0, Math.min(suggestedDecade, 9)); 
                    }
                } else {
                    // No está en modo serie o en modo aleatorio, usa el valor previamente establecido o el predeterminado.
                    if (parseInt(state.digits) === 1) {
                        suggestedDecade = 0;
                    } else if (parseInt(state.digits) === 2 && state.seriesStartMaxDecade === 0) {
                        suggestedDecade = 1; // Predeterminado a rango 10-19 para 2 dígitos si actualmente es 0-9
                    }
                }

                // Limita el suggestedDecade final dentro del mínimo/máximo absoluto del slider
                state.seriesStartMaxDecade = Math.max(0, Math.min(suggestedDecade, 9)); 
                seriesStartRangeSlider.value = state.seriesStartMaxDecade; // Actualiza la visualización del slider

                const displayMin = state.seriesStartMaxDecade * 10;
                const displayMax = Math.min(displayMin + 9, (parseInt(state.digits) === 1 ? 9 : 99)); // Limita a 9 o 99
                seriesStartRangeLabel.textContent = `${displayMin} - ${displayMax}`;
            };

            const renderPyramidSizeButtons = () => {
                pyramidSizeButtonsContainer.innerHTML = '';
                const sizes = ['2-1', '4-2-1'];
                sizes.forEach(size => {
                    const sizeBtn = document.createElement('button');
                    sizeBtn.textContent = size;
                    sizeBtn.dataset.value = size;
                    const isSelected = state.pyramidSize === size;
                    sizeBtn.className = `pyramid-size-button p-3 rounded-lg text-center transition-colors duration-200 text-sm font-medium ${isSelected ? 'bg-blue-600 text-white shadow-md' : 'bg-gray-200 text-gray-800 hover:bg-gray-300'}`;
                    sizeBtn.disabled = state.operation !== 'pyramid';
                    pyramidSizeButtonsContainer.appendChild(sizeBtn);
                });
            };

            const updateTablaNumericaControls = () => {
                tablaNumericaControls.querySelectorAll('button').forEach(btn => {
                    const value = btn.dataset.value;
                    btn.classList.toggle('bg-blue-600', value === state.tablaNumericaType);
                    btn.classList.toggle('text-white', value === state.tablaNumericaType);
                    btn.classList.toggle('shadow-md', value === state.tablaNumericaType);
                    btn.classList.toggle('bg-gray-200', value !== state.tablaNumericaType);
                    btn.classList.toggle('text-gray-800', value !== state.tablaNumericaType);
                });
            };


            // --- Event Listeners ---
            operationButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button) {
                    state.operation = button.dataset.value;
                    updateOperationControls(); 
                    renderSeriesPatternButtons(); 
                    renderSeriesDirectionButtons(); 
                    updateSeriesStartRangeSlider(); // Llamar después de posibles ajustes de dígitos
                    renderPyramidSizeButtons();
                    updateTablaNumericaControls();
                    generateProblems(); 
                }
            });

            digitButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && !button.disabled) {
                    state.digits = button.dataset.value;
                    updateDigitControls();
                    generateProblems(); 
                }
            });
            
            numProblemsButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button) {
                    state.numProblems = parseInt(button.dataset.value);
                    updateNumProblemsControls();
                    generateProblems(); 
                }
            });

            multiplicationTablesContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && (state.operation === 'multiplicacion' || state.operation === 'diana-multiplicaciones')) {
                    const index = parseInt(button.dataset.index);
                    state.tables[index] = !state.tables[index];
                    button.classList.toggle('bg-blue-500');
                    button.classList.toggle('text-white');
                    button.classList.toggle('bg-gray-200');
                    button.classList.toggle('text-gray-700');
                    generateProblems();
                }
            });

            seriesPatternButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'series' && !state.randomSeriesMode) { 
                    const index = parseInt(button.dataset.index);
                    state.seriesPatterns[index] = !state.seriesPatterns[index]; 
                    renderSeriesPatternButtons(); 
                    updateSeriesStartRangeSlider(); // Actualiza el slider después de cambiar el patrón
                    generateProblems();
                }
            });

            seriesDirectionButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'series' && !state.randomSeriesMode) { 
                    const value = button.dataset.value;
                    const index = state.seriesDirections.indexOf(value);
                    if (index > -1) {
                        state.seriesDirections.splice(index, 1); 
                    } else {
                        state.seriesDirections.push(value); 
                    }
                    renderSeriesDirectionButtons(); 
                    generateProblems();
                }
            });

            randomSeriesCheckbox.addEventListener('change', (e) => {
                state.randomSeriesMode = e.target.checked;
                updateOperationControls(); 
                renderSeriesPatternButtons(); 
                renderSeriesDirectionButtons(); 
                updateSeriesStartRangeSlider(); // Actualiza el slider cuando cambia el modo aleatorio
                generateProblems(); 
            });

            seriesStartRangeSlider.addEventListener('input', (e) => {
                state.seriesStartMaxDecade = parseInt(e.target.value);
                updateSeriesStartRangeSlider(); 
                generateProblems(); 
            });

            pyramidSizeButtonsContainer.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'pyramid') {
                    state.pyramidSize = button.dataset.value;
                    renderPyramidSizeButtons();
                    generateProblems();
                }
            });

            tablaNumericaControls.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (button && state.operation === 'tabla-numerica') {
                    state.tablaNumericaType = button.dataset.value;
                    updateTablaNumericaControls();
                    generateProblems(); 
                }
            });


            generateBtn.addEventListener('click', () => generateProblems());

            // Función para reiniciar el estado a valores predeterminados y generar problemas
            const resetStateAndGenerate = () => {
                state.operation = 'suma-llevada';
                state.digits = '2';
                state.numProblems = 30;
                state.tables = new Array(10).fill(true);
                state.seriesPatterns = [true, false, false, false, false, false, false, false, false, false];
                state.seriesDirections = ['progresiva'];
                state.randomSeriesMode = false;
                state.seriesStartMaxDecade = 9; // Predeterminado para 2 dígitos, patrón +1
                state.pyramidSize = '2-1';
                state.tablaNumericaType = '1-100';
                state.problems = [];

                // Actualiza la UI para reflejar el estado reiniciado
                updateOperationControls();
                updateDigitControls();
                updateNumProblemsControls();
                renderTableButtons();
                renderSeriesPatternButtons();
                renderSeriesDirectionButtons();
                updateSeriesStartRangeSlider();
                renderPyramidSizeButtons();
                updateTablaNumericaControls();
                
                generateProblems(); // Intenta generar con el estado reiniciado
            };

            // Modificado: El botón de cerrar alerta ahora reinicia la generación
            alertCloseBtn.addEventListener('click', () => {
                hideAlert();
                resetStateAndGenerate(); // Reinicia la generación de problemas
            });


            const prepareWorksheetForPDF = async (showAnswers) => {
                // Asegúrate de que las fuentes estén cargadas antes de capturar el canvas
                await document.fonts.ready;

                const titleMap = {
                    'suma-simple': 'Hoja de Sumas Simples',
                    'suma-llevada': 'Hoja de Sumas con Llevada',
                    'resta-simple': 'Hoja de Restas Simples',
                    'resta-llevada': 'Hoja de Restas con Llevada',
                    'multiplicacion': 'Hoja de Multiplicaciones',
                    'series': 'Hoja de Series Numéricas',
                    'pyramid': 'Hoja de Pirámides Matemáticas',
                    'diana-multiplicaciones': 'Hoja de Diana de Multiplicaciones'
                };

                // Establece el título de la hoja de trabajo basándose en la operación actual
                let worksheetPdfTitle = 'Hoja de Ejercicios de Matemáticas';
                if (state.operation === 'tabla-numerica') {
                    if (state.tablaNumericaType === '1-100') {
                        worksheetPdfTitle = 'Hoja de Tabla Numérica';
                    } else if (state.tablaNumericaType === 'pitagorica') {
                        worksheetPdfTitle = 'Hoja de Tabla Pitagórica'; // Título actualizado para la tabla pitagórica
                    }
                } else {
                    worksheetPdfTitle = titleMap[state.operation] || worksheetPdfTitle;
                }

                if (worksheetTitleElement) {
                    worksheetTitleElement.textContent = worksheetPdfTitle;
                }

                // Almacena los estilos originales de la hoja de trabajo para revertirlos más tarde
                worksheet.originalStyle = worksheet.style.cssText;
                
                // Aplica las dimensiones A4 y el relleno para una renderización PDF consistente
                worksheet.style.width = '210mm'; // Ancho A4
                worksheet.style.maxWidth = '210mm'; // Asegúrate de que no se expanda más allá del ancho A4
                worksheet.style.padding = '10mm'; // Añade relleno para simular los márgenes del PDF
                worksheet.style.boxSizing = 'border-box'; // Asegúrate de que el relleno se incluya en el ancho/alto total
                worksheet.style.aspectRatio = 'auto'; // Anula la relación de aspecto para dimensiones fijas
                worksheet.style.overflow = 'visible'; // Crucial: Asegúrate de que todo el contenido se capture, incluso si se desborda inicialmente

                // Oculta los controles y botones de acción
                const controlsPanel = document.querySelector('.grid-cols-1.lg\\:grid-cols-3.gap-6.mb-8');
                const actionButtons = document.querySelector('.flex.flex-col.sm\\:flex-row.items-center');
                // Almacena los valores de visualización originales si existen
                if(controlsPanel) controlsPanel.originalDisplay = controlsPanel.style.display;
                if(actionButtons) actionButtons.originalDisplay = actionButtons.style.display;

                if(controlsPanel) controlsPanel.style.display = 'none';
                if(actionButtons) actionButtons.style.display = 'none';
                
                renderProblems(state.problems, showAnswers); // Renderiza los problemas con/sin respuestas
            };

            const restoreWorksheetFromPDF = () => {
                // Restaura los estilos originales de la hoja de trabajo
                worksheet.style.cssText = worksheet.originalStyle || '';
                worksheet.style.width = '';
                worksheet.style.height = '';
                worksheet.style.maxWidth = '';
                worksheet.style.padding = '';
                worksheet.style.boxSizing = '';
                worksheet.style.aspectRatio = '';
                worksheet.style.overflow = '';

                // Restaura los controles y botones de acción
                const controlsPanel = document.querySelector('.grid-cols-1.lg\\:grid-cols-3.gap-6.mb-8');
                const actionButtons = document.querySelector('.flex.flex-col.sm\\:flex-row.items-center');
                if(controlsPanel) controlsPanel.style.display = controlsPanel.originalDisplay || '';
                if(actionButtons) actionButtons.style.display = actionButtons.originalDisplay || '';
                
                renderProblems(state.problems, false); // Vuelve a renderizar los problemas para la pantalla sin respuestas
            };

            // ========== EXPORTACIÓN PDF ROBUSTA CON ENCABEZADO PERSONALIZADO ==========

            async function generarPDF(previsualizar = false, showAnswers = false) {
                try {
                    if (typeof showLoading === "function") showLoading("Generando PDF...");

                    // Oculta el modal de alerta si está visible
                    if (document.getElementById('alert-modal')) document.getElementById('alert-modal').classList.remove('visible');
                    
                    // Prepara la hoja de trabajo para la exportación a PDF (establece dimensiones, oculta controles, renderiza problemas con/sin respuestas)
                    await prepareWorksheetForPDF(showAnswers); // Espera esta llamada
                    await new Promise(r => setTimeout(r, 100)); // Pequeño retraso para asegurar las actualizaciones del DOM

                    const worksheet = document.getElementById('worksheet');
                    if (!worksheet) {
                        if (typeof showAlert === "function") showAlert('No se encontró la hoja para exportar.');
                        return;
                    }

                    // Obtiene el título actual de la hoja de trabajo
                    const currentWorksheetTitle = worksheetTitleElement.textContent.replace(/ /g, '_').toLowerCase(); // Reemplaza espacios con guiones bajos para el nombre del archivo

                    // Construye el nombre del archivo
                    const fecha = new Date().toISOString().slice(0, 10);
                    const finalFileName = `${currentWorksheetTitle}${showAnswers ? '_con_respuestas' : ''}_${fecha}.pdf`;
                    
                    const canvas = await html2canvas(worksheet, {
                        scale: 3, // Escala alta para mejor calidad
                        useCORS: true,
                        backgroundColor: '#fff'
                    });
                    
                    const { jsPDF } = window.jspdf; // Instanciación correcta
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm', 
                        format: 'a4'
                    });
                    
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const pdfMargin = 10; // mm

                    let imgWidthInPdf = pdfWidth - (2 * pdfMargin); // Ancho de la imagen en PDF, respetando los márgenes
                    let imgHeightInPdf = (canvas.height * imgWidthInPdf) / canvas.width; // Altura total escalada de todo el contenido del canvas

                    let currentCanvasY = 0; // Posición Y actual en el canvas original
                    let currentPageY = pdfMargin; // Posición Y actual en la página PDF actual

                    // Si el contenido es más grande que una página, lo divide
                    if (imgHeightInPdf > pdfHeight - (2 * pdfMargin)) {
                        while (currentCanvasY < canvas.height) {
                            if (currentCanvasY > 0) { // Añade una nueva página para los segmentos siguientes
                                pdf.addPage();
                                currentPageY = pdfMargin; // Reinicia la Y para la nueva página
                            }

                            // Calcula la altura del contenido del canvas que cabe en una página PDF
                            const canvasSegmentHeightPx = (pdfHeight - (2 * pdfMargin)) * (canvas.width / imgWidthInPdf);

                            // Determina la altura real del segmento a cortar del canvas original para esta página
                            const clipHeightPx = Math.min(canvas.height - currentCanvasY, canvasSegmentHeightPx);

                            // Crea un canvas temporal para este segmento
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = canvas.width;
                            tempCanvas.height = clipHeightPx;
                            const tempCtx = tempCanvas.getContext('2d');
                            // Dibuja el segmento actual del canvas original en el canvas temporal
                            tempCtx.drawImage(canvas, 0, currentCanvasY, canvas.width, clipHeightPx, 0, 0, canvas.width, clipHeightPx);

                            const tempImgData = tempCanvas.toDataURL('image/png');
                            
                            // Calcula la altura de este segmento cuando se escala a las dimensiones del PDF
                            const segmentHeightInPdf = (clipHeightPx * imgWidthInPdf) / canvas.width;

                            // Añade la imagen del segmento al PDF
                            pdf.addImage(tempImgData, 'PNG', pdfMargin, currentPageY, imgWidthInPdf, segmentHeightInPdf);

                            currentCanvasY += clipHeightPx; // Pasa al siguiente segmento en el canvas original
                        }
                    } else {
                        // Si cabe en una sola página, lo centra verticalmente
                        const xOffset = (pdfWidth - imgWidthInPdf) / 2;
                        const yOffset = (pdfHeight - imgHeightInPdf) / 2;
                        pdf.addImage(canvas.toDataURL('image/png'), "PNG", xOffset, yOffset, imgWidthInPdf, imgHeightInPdf);
                    }
                    
                    if (previsualizar) {
                        window.open(pdf.output('bloburl'), '_blank');
                    } else {
                        pdf.save(finalFileName); // Usa el nombre de archivo generado dinámicamente
                    }
                } catch (err) {
                    if (typeof showAlert === "function") showAlert('Error al generar el PDF: ' + err.message);
                    console.error('Error al generar el PDF:', err);
                } finally {
                    if (typeof hideLoading === "function") hideLoading();
                    restoreWorksheetFromPDF(); // Siempre restaura la vista original
                }
            }

            async function exportarEjerciciosPDF() {
                if (state.problems.length === 0) {
                    showAlert("Primero genera una hoja de trabajo para poder descargarla.");
                    return;
                }
                await generarPDF(false, false); // No es necesario pasar el nombre del archivo, se genera dinámicamente
            }

            async function exportarRespuestasPDF() {
                if (state.problems.length === 0) {
                    showAlert("Primero genera una hoja de trabajo para poder descargarla con respuestas.");
                    return;
                }
                await generarPDF(false, true); // No es necesario pasar el nombre del archivo, se genera dinámicamente
            }

            // Event listeners para los botones de descarga
            const btnEjercicios = document.getElementById('download-btn');
            const btnRespuestas = document.getElementById('download-answers-btn');
            if (btnEjercicios) btnEjercicios.addEventListener('click', exportarEjerciciosPDF);
            if (btnRespuestas) btnRespuestas.addEventListener('click', exportarRespuestasPDF);

            // --- Inicialización ---
            renderTableButtons();
            renderSeriesPatternButtons();
            renderSeriesDirectionButtons();
            updateSeriesStartRangeSlider();
            renderPyramidSizeButtons();
            updateOperationControls();
            updateDigitControls();
            updateTablaNumericaControls();
            generateProblems(); 
        });
    </script>
</body>
</html>
